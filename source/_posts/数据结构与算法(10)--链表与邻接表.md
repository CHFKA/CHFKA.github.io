---
title: 链表与邻接表
date: 2021-08-12  17:16:30 
tags: 算法
---

# 介绍  

使用数组(静态链表)来模拟单链表和双链表，使用new(动态链表)会超时。

- 单链表----->邻接表：存储图和树
- 双链表----->优化某些问题

<!-- more -->  

## 链表与邻接表

### 单链表

------

实现一个单链表，链表初始为空，支持三种操作：

1. 向链表头插入一个数；
2. 删除第 k 个插入的数后面的数；
3. 在第 k个插入的数后插入一个数。

现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。

**注意**:题目中第 k个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1个插入的数，第 2 个插入的数，…第 n个插入的数。

------

$head(头节点)->O(指针，值)->\phi(空指针)$

现用head代表头节点的下标，e[N]代表值，ne[N]代表节点i的next指针，idx代表使用了多少的节点

实现:

```c++
#include<iostream>
using namespace std;
const int N = 100010;
int head,e[N],ne[N],idx;
void init()
{
    head = -1;
    idx = 0;
}
//将x插到头节点
void add_to_head(int x)
{
    e[idx] = x;
    ne[idx] = head;
    head = idx++;
    
}
//将x插到k下标的后面
void add(int k,int x)
{
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx++;
    
}
//将下标是k的点删除
void remove(int k)
{
    ne[k] = ne[ne[k]];
}
int main()
{
    int m;
    cin >> m;
    init();
    while(m--)
    {
        int k,x;
        char op;
        cin >> op;
        if(op == 'H')
        {
            cin >> x;
            add_to_head(x);
        }
        else if(op == 'D')
        {
            cin >> k;
            if(!k)
            {
                head = ne[head];
            }
            remove(k - 1);
        }
        else 
        {
            cin >> k >> x;
            add(k-1,x);
        }
        
    }
    for(int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
    cout << endl;
    return 0;
}
```

### 双链表

------

实现一个双链表，双链表初始为空，支持 55 种操作：

1. 在最左侧插入一个数；
2. 在最右侧插入一个数；
3. 将第 k 个插入的数删除；
4. 在第 k 个插入的数左侧插入一个数；
5. 在第 k 个插入的数右侧插入一个数

现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。

**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

------

现用e[N]代表值，l[N]代表节点i的左边指针，r[N]代表节点i的右边指针，idx代表使用了多少的节点

实现：

```c++
#include<iostream>
using namespace std;
const  int N = 100010;
int m;
int e[N],l[N],r[N],idx;

void init()
{
    r[0] = 1;
    l[0] = 0;
    idx = 2;
}

void add(int k, int x)
{
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
    idx++; 
}

void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main()
{
    int m;
    cin >> m;
    init();
    while(m--)
    {
        int k,x;
        string op;
        cin >> op;
        if(op == "L")
        {
            cin >> x;
            add(0,x);
        }
        else if(op == "R")
        {
            cin >> x;
            add(l[1],x);
        }
        else if(op == "D")
        {
            cin >> k;
            remove(k + 1);
        }
        else if(op == "IL")
        {
            cin >> k >> x;
            add(l[k+1],x);
        }
        else
        {
            cin >> k >> x;
            add(k+1,x);
        }
        
    }
    for(int i = r[0]; i != 1; i = r[i]) cout << e[i] << ' ';
    cout << endl;
    return 0;
}

```

