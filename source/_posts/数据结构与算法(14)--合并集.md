---
title: 合并集
date: 2021-09-20 13:58:50
tags: 算法
---

# 介绍  

并查集：

1. 快速将两集合合并
2. 查询两个元素是否在一个集合中

<!-- more -->  

# 并查集

- 每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。
- 树根：用p[x] == x 来表示
- x的集合编号：用while(p[x] != x) x= p[x]; 
- 合并集合：px是x的集合编号，py是y的集合编号。p[x] = y

------

一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。

现在要进行 m 个操作，操作共有两种：

1. `M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
2. `Q a b`，询问编号为 a 和 b 的两个数是否在同一个集合中；

------

实现：

```c++
#include<iostream>
using namespace std;
const int N = 100010;

int n,m;
int p[N];
//核心操作
int find(int x)//返回x的根节点+路径压缩  
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    scanf("%d%d",&n, &m);
    for(int i = 1; i <= n; i++) p[i] = i;
    while(m--)
    {  
      	char op[2];
        int a,b;
        scanf("%s%d%d",op,&a,&b);
        if(op[0] == 'M') p[find(a)] = find(b);
        else 
        {
            if(find(a) == find(b)) puts("Yes");
            else puts("NO");
        }
    }
    return 0;
}
```

## 变式

给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。

现在要进行 m 个操作，操作共有三种：

1. `C a b`，在点 a 和点 b 之间连一条边，a 和 b 可能相等；
2. `Q1 a b`，询问点 a和点 b 是否在同一个连通块中，a 和 b 可能相等；
3. `Q2 a`，询问点 a 所在连通块中点的数量

------

实现：

```c++
#include<iostream>
using namespace std;
const int N = 100010;

int n,m;
int p[N],siz[N];
//核心操作
int find(int x)//返回x的根节点+路径压缩  
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    scanf("%d%d",&n, &m);
    for(int i = 1; i <= n; i++) 
    {
        p[i] = i;
        siz[i] = 1;
    }
    while(m--)
    {  
      	char op[5];
        int a,b;
        scanf("%s",op);
        if(op[0] == 'C')
        {
            scnaf("%d%d",&a,&b);
            if(find(a) == find(b)) continue;
            size[find(b)] += siz[find(a)];
            p[find(a)] = find(b);
        }
        else if(op[1] == '1')
        {
            scnaf("%d%d",&a,&b);
            if(find(a) == find(b)) puts("Yes");
            else puts("NO");
        }
        else 
        {
            scanf("%d",&a);
            prindf("%d\n",siz[find(a)]);
        }
    }
    return 0;
}
```

