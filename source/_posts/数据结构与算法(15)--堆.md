---
title: 堆
date: 2021-09-21 16:08:52
tags: 算法
---

# 介绍  

如何手写一个堆

1. 插入一个数
2. 求集合当中的最小值
3. 删除最小值
4. 删除任意一个元素
5. 修改任意一个元素

<!-- more -->  

# 堆

基本结构：一棵完全二叉树。

- 小根堆：父节点的值小于或等于子节点的值；
- 大根堆：父节点的值大于或等于子节点的值；

存储：使用1维数组存储。假设存储根节点的下标为x，则左子节点为2x，右子节点为2x+1。

操作：down(x);up(x);---- x代表下标

## down(x)操作

- 本质是一个递归过程

------

输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。

------

实现：

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 100010;

int n,m;
int h[N],size;

void down(int u)
{
    int t = u;
    if(u * 2 <= size && h[u * 2] < h[t]) t = u * 2;//比较当前节点的左子节点
    if(u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;//比较当前节点的右子节点
    if(u != t)//根据下标变换对应的值
    {
        swap(h[u], h[t]);
        down(t);
    }
}



int main()
{
    scanf("%d%d",&n, &m);
    for(int i = 1; i <= n; i++) scanf("%d", &h[i]);
    size = n;
    //建堆  O(n)时间复杂度
    for(int i = n / 2; i; i--) down(i);
    while(m--)
    {
        printf("%d",h[1]);
        h[1] = h[size];
        size--;
        down(1);
    }
    return 0;
}

```

## up(x)操作

```c++
void up(int u)
{
    while(u / 2 && h[u / 2] > h[u])
    {
        swap(h[u/2], h[u]);
        u /= 2;
    }
}
```

##  模拟堆

维护一个集合，初始时集合为空，支持如下几种操作：

1. `I x`，插入一个数 xx；
2. `PM`，输出当前集合中的最小值；
3. `DM`，删除当前集合中的最小值（数据保证此时的最小值唯一）；
4. `D k`，删除第 kk 个插入的数；
5. `C k x`，修改第 kk 个插入的数，将其变为 xx；

现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。

------

实现：

```c++
#include<iostream>
#include<algorithm>
#include<string.h>
using namespace std;

const int N = 100010;

int n,m;
int h[N],size;
//hp是heap pointer的缩写，表示堆数组中下标到第k个插入的映射
//ph是pointer heap的缩写，表示第k个插入到堆数组中的下标的映射
//两个互为逆函数。
int ph[N], hp[N];

void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void up(int u)
{
    while(u / 2 && h[u / 2] > h[u])
    {
        heap_swap(u/2, u);
        u /= 2;
    }
}
void down(int u)
{
    int t = u;
    if(u * 2 <= size && h[u * 2] < h[t]) t = u * 2;//比较当前节点的左子节点
    if(u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;//比较当前节点的右子节点
    if(u != t)//根据下标变换对应的值
    {
        heap_swap(u, t);
        down(t);
    }
}



int main()
{
    int n, m = 0;
    scanf("%d",&n);
    while(n--)
    {
        char op[10];
        int k,x;
        scanf("%s",op);
        if(!strcmp(op,"I"))
        {
            scanf("%d",&x);
            size++;
            m++;
            ph[m] = size, hp[size] = m;
            h[size] = x;
            up(size);
        }
        else if(!strcmp(op,"PM")) printf("%d\n", h[1]);
        else if(!strcmp(op,"DM"))
        {
            heap_swap(1,size);
            size -- ;
            down(1);
        }
        else if(!strcmp(op,"D"))
        {
            scanf("%d",&k);
            k = ph[k];
            heap_swap(k,size);
            size -- ;
            down(k),
            up(k);
        }
        else 
        {
            scanf("%d%d", &k, &x);
            k =ph[k];
            h[k] = x;
            down(k);
            up(k);
        }
    }
    return 0;
}
```

为什么会用ph和hp这两个数组呢？
原因在于在删除第k个插入元素的操作中，我们首先得知道第k个插入元素在堆数组中的什么位置，即堆数组下标是啥。很显然，用一个ph数组来存储会方便查找。这样我们就知道了第k个插入的元素在哪了。然后我们需要做的是和堆尾元素交换，最后再在原来第k个元素所在的位置进行down和up操作。由于交换完后ph[k]的值变了，为ph[size]了，所以必须要在之前保存ph[k]的值，不然无法进行down和up操作。
