---
title: 计算机网络(2)-应用层
date: 2022-01-05 22:00:59
tags: 计算机网络
---
## 概述

- 网络应用的原理：网络应用协议的概念和实现方面

  - 传输层的服务模型
  - 客户-服务器模式
  - 对等模式(peer to peer)
  - 内容分发网络
- 网络应用的实例：互联网流行的应用层协议

  - HTTP
  - FTP
  - SMTP/POP3/IMAP
  - DNS
- 编程：网络应用程序

  - Socket API--传输层提供的服务

<!-- more -->

## 协议原理

### 应用架构

- 客户-服务器(C/S)体系结构--达到一定量级后断崖式下降

  - 服务器

    - 一直运行
    - 固定的IP地址和周知的端口号
    - 扩展性：服务器场

      - 数据中心进行扩展
      - 扩展性差
  - 客户端

    - 主动与服务端通信
    - 与互联网有间歇性的连接
    - 可能是动态IP地址
    - 不直接与其他客户端通信
- 对等模式(P2P: Peer To Peer)

  - (几乎)没有一直运行的服务器
  - 任意端系统之间可以进行通信
  - 每一个节点即是客户端又是服务器

    - 自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求
  - 参与的主机间歇性连接且可以改变IP地址

    - 难以管理
- 混合模式:客户端-服务器和对等体系结构

  - Napster

    - 文件搜索：集中

      - 主机在中心服务器上注册其资源
      - 主机向中心服务器查询资源位置
    - 文件传输：P2P

      - 任意peer节点之间
  - 即时通信

    - 在线检测：集中

      - 当用户上线时，向中心服务器注册其IP地址
      - 用户与中心服务器联系，以找到其在线好友的位置
    - 两个用户之间聊天：P2P

### 进程通信

  进程：在主机上运行的应用程序

- 在同一主机内，使用进程间通信机制通信
- 不同主机，通过交换报文(Message)来通信

  - 使用OS提供的通信服务
  - 按照应用协议交换报文 -- 借助传输层提供的服务
- 具体实现

  - 客户端进程：发起通信的进程
  - 服务器进程：等待连接的进程
- 注意：P2P架构的应用也有客户端进程和服务器进程之分

#### 分布式通信进程

- 存在的问题

  1. 标示和寻址(服务用户)
  2. 传输层-应用层提供服务是如何的(服务)

     - 位置：层间界面的SAP [服务访问点] (TCP/IP：socket)
     - 形式：应用程序接口API(TCP/IP：socket API)
  3. 如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用(用户使用服务)

     - 定义应用层协议：报文格式，解释，时序等
     - 编制程序，使用OS提供的API，调用网络基础设施提供通信服务传报文，实现应用时序等。
- 解决方法

  1. 对进程进行编址-addressing

     本质上一对主机进程间的通信由2个端节点构成

     - 进程为了接收报文，必须有一个**标识**：**SAP**(发送也需要标示)

       - 主机：唯一的32位IP地址--仅仅有IP地址不能够唯一标示一个进程；在一条端系统上有很多应用进程在运行
       - 传输层协议：TCP或UDP
       - 端口号
     - 一个进程：用IP+port 标示 端节点
  2. 传输层提供的服务--需要穿过层间的信息

     - 层间接口必须要携带的信息

       - 要传输的报文(对于本层来说：SDU)
       - 谁传的：对方的应用进程的标示：IP+TCP(UDP)端口
       - 传给谁：对方的应用进程的标示：对方的IP+TCP(UDP)端口
     - 传输层实体(TCP或者UDP实体)根据这些信息进行TCP报文段(UDP数据报)的封装

       - 源端口号，目标端口号，数据等
       - 将IP地址往下交IP实体，用于封装IP数据报：源IP，目标IP
     - 对于面向连接服务(TCP)的应用而言，套接字是4元组的具有本地意义的标识

       - 4元组(源IP，源port，目标IP，目标port)
       - 唯一的指定了一个会话(2个进程间的会话关系)
       - 应用使用这个标示，与远程的应用进行通信
       - 不必每个报文的发送都要指定这4元组
       - 使用的是类似句柄的存在
       - 便于管理、简单
       - 操作系统需要维护一张表--socket值 4元组+状态
     - UDP socket

       - 2元组 (IP, port 源端指定)
       - 指定了应用所在的一个端节点
       - 在发送数据报时，采用创建好的本地套接字(标示ID)，就不必每个报文中指明自己所采用的ip和port
       - 但是在发送报文时，必须指定对发的ip和UDP port
  3. 使用传输层的提供的服务实现应用

     - 应用层协议--是在应用的一部分
       - 定义了运行在不同端系统上的应用进程如何交换报文

         - 报文类型
         - 报文的类型的语法
         - 字段的语义：即字段取值的含义
         - 进程何时，如何发送报文及对报文进行响应的规则
       - 指标

         - 数据丢失率
         - 延迟
         - 吞吐
         - 安全性
           - 机密性
           - 完整性
           - 可认证性(鉴别)
     - 传输层提供的服务
       - TCP
         - 可靠的传输服务
         - 流量控制
         - 拥塞控制
         - 不能提供的服务：时间保证、最小吞吐保证和安全
         - 面向连接
       - UDP
         - 不可靠
         - 不提供服务：可靠、流量控制、拥塞控制、时间、带宽保证、建立连接
         - 存在的理由
           - 区分不同的进程
           - 无需连接
           - 不做可靠性的工作
           - 应用能够按照设定的速度发送数据
- 安全TCP

  - SSL
    - 在TCP上面实现，提供加密的TCP连接
    - 私密性
    - 数据完整性
    - 端到端的鉴别
    - 在应用层

## Web and HTTP

### 术语

- web页：由一些对象组成
  - 对象可以时HTML文件，JPEG图像，Java小程序，声音剪辑文件
  - web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用
  - 通过URL对每个对象进行引用

    - 访问协议，用户名，口令字，端口等
  - URL格式：

    协议名  用户：口令  主机名        路径名  端口
    Prot：//ueser:psd@www.some.com/xxx.gif:port

### HTTP

- HTTP：超文本传输协议
  - web的应用层协议
  - 客户/服务器模式

    - 客户：请求、接收和显示Web对象的浏览器
    - 服务器：对请求进行响应，发送对象的Web服务器
  - 工作原理：

    - 客户端发起一个与服务器的TCP连接(独立套接字)，端口号为80
    - 服务器接受客户的TCP连接
    - 在浏览器(HTTP客户端)与Web服务器(HTTP服务器server)交换HTTP报文(应用层协议报文)
    - TCP关闭

    注：HTTP是**无状态**的：服务器不维护关于客户的任何信息。无状态的服务器能够支持更多的客户端。
  - HTTP连接

    - 非持久
      - 最多只有一个对象在TCP连接上发送
      - 下载多个对象需要多个TCP连接
      - HTTP/1.0 使用非持久连接
      - 缺点：
        - 每个对象要2个RTT
        - 操作系统必须为每个TCP连接分配资源
        - 但浏览器通常打开并行TCP连接，以获取引用对象
    - 持久
      - 多个对象可以在一个(在客户端和服务器之间)TCP连接上传输
      - HTTP/1.1默认使用持久连接
      - 服务器在发送响应后，仍保持TCP连接
      - 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传递
      - 客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求
      - 非流水方式的持久HTTP：
        - 客户端只能在收到前一个响应后才能发出新的请求
        - 每个引用对象花费一个RTT
      - 流水方式的持久HTTP
        - HTTP/1.1的默认模式
        - 客户遇到一个引用对象就立即产生一个请求
        - 所有引用对象只花费一个RTT是可能的
  - 响应时间模型

    往返时间RTT(round-trip-time)：一个小的分组从客户端到服务器，在回到客户端的时间
    响应时间：

    - 一个RTT用来发起TCP连接
    - 一个RTT用来HTTP请求并等待HTTP响应
    - 文件传输

    注：共 2RTT+传输时间
  - HTTP请求报文

    - 类型：请求、响应
    - 请求报文：
      ASCII(人能阅读)

      ```http
      请求行（GET、POST、HEAD命令）
      GET /xxx/xxxx/page.html HTTP/1.1
      Host: www.xxx.com
      User-agent: Mozilla/4.0
      Connection：close
      Accept-language:fr
      --换行回车符，表示报文结束--
      请求行
      首部行
      请求体
      ```

      - 提交表单输入方式
        - Post
          1. 网页通常包括表单输入
          2. 包含在实体主体(entity body)中的输入被提交到服务器
        - URL
          1. 方法：GET
          2. 输入通过请求行的URL字段上载
    - 方法类型

      1. HTTP/1.0
         - GET
         - POST
         - HEAD：要求服务器在响应报文中不包含请求对象->故障跟踪
      2. HTTP/1.1
         - GET、POST、HEAD
         - PUT：将实体主体中的文件上载到URL字段规定的路径中
         - DELETE：删除URL字段规定的文件
  - HTTP响应报文

    ```http
    状态行 HTTP/1.1 200 OK\r\n
    首部行:
          Connection close\r\n
          Date:
          Server
          Last-Modified
          Content-Length
          Content-Type
    数据，如请求的HTML文件
    ```

  - 用户-服务器状态：cookies--维护状态

    - 概念：
      - 缓存既是客户端又是服务器
      - 通常缓存是由ISP安装(大学、公司、居民区ISP)
    - 组成部分：
      - 在http响应报文中有一个cookie的首部行
      - 在http请求报文含有一个cookie的首部行
      - 在用户端系统中保留有一个cookie文件，由用户的浏览器管理
      - 在web站点有一个后端数据库
    - 作用
      - 用户验证
      - 购物车
      - 推荐
      - 用户状态（Web e-mail）
    - 如何维持状态
      - 协议端节点：在多个事务上，发送端和接收端维持状态
      - cookies： http报文携带状态信息
    - 存在隐私性问题
  - web cache缓存(代理服务器)

    - 目的：不访问原始服务器，就满足客户的请求

      - 用户设置浏览器：通过缓存访问web
      - 浏览器将所有的HTTP请求发给缓存
        - 在缓存中的对象：缓存直接返回对象
        - 如果对象不在缓存。缓存请求原始服务器，然后再将对象返回给客户端
    - 使用的优点

      1. 降低客户端的请求响应时间
      2. 可以大大减少一个机构内部与Internet接入链路上的流量
      3. 互联网大量采用缓存：可以使较弱的ICP也能够有效提供内容
    - 缓存示例

      ```webcache
      假设：
      平均对象大小 = 100kb
      局域网的带宽为1Gbps
      机构内浏览器对原始服务器的平均请求速率 = 15 请求/s
      平均到浏览器的速率： 1.5Mbps
      机构内部路由器到原始服务器再返回到路由器的延时 = 2s
      接入链路带宽： 1.54 Mbps
      结果：
      LAN的流量强度 = 0.15 %
      接入链路上的流量强度 = 99%
      总延时 = LAN延时 + 接入延时 + Internet延时
      解决方法：
      1.增加接入链路带宽(非常昂贵)
      2.安装本地缓存
        假设0.6需要去访问远程服务器
        速率 = 0.6 * 1.5 = 0.9 Mbps
        接入链路上的流量强度 = 0.9 / 1.54 = 0.58
        总体延迟 = 0.6*（从原始服务器获取对象的延迟）+ 0.4（从缓存获取对象的延迟）
      ```

    - 条件GET获取

      使用Last-Modified来判断缓存是否需要更新。

      - 缓存器在HTTP请求中指定缓存拷贝的日期：

        ```http
          if-modified-since：
            <date>
        ```

      - 服务器：如果对象没变返回下列所述。如果改变则正常返回

        ```http
        HTTP/1.0 304 Not
          Modified
        ```

## FTP

- 向远程主机上传输文件或从远程主机接收文件
- 客户/服务模式
- ftp：RFC959
- ftp服务器：端口号为21.使用TCP作为传输协议（明文传输）
  - 数据传输是通过另一个端口发出
  - 一个是控制端口，一个传输端口(带外传送)
  - ftp服务器维护用户的状态信息：当前路径，用户账户与控制连接对应。
  - 有状态协议
- FTP命令：在控制连接上以ASCII文本方式传送
- 返回码的状态码和状态信息同HTTP

## Email

- 3个主要组成部分
  - 用户代理
    - 邮件阅读器
    - 撰写、编辑和阅读邮件，如Outlook、foxmail
    - 输出和输入邮件保存在服务器上
  - 邮件服务器
  - 简单邮件传输协议：SMTP
- 邮件服务器
  - 邮箱中管理和维护发送给用户
  - 输出报文队列保持发送邮件报文
  - 邮件服务器之间的SMTP协议：发送email报文
    - 客户：发送方邮件服务器
    - 服务器：接收端邮件服务器

### SMTP【RFC 2821】

- 使用TCP在客户端和服务器之间传送报文，端口号为25
- 直接传输：从发送方服务器到接收方服务器
- 传输的3个阶段
  - 握手
  - 传输报文
  - 关闭
- 命令/响应交互
  - 命令：ASCII文本
  - 响应：状态码和状态信息
- 报文必须为7位ASCII码
- 使用持久连接
- SMTP服务器使用CRLF。CRLF决定报文的尾部
- 与HTTP比较
  - HTTP： 拉（pull）客户端向服务器请求
  - SMTP： 推（push）客户端发送到服务器中
  - 二者都是ASCII形式的命令/响应交互、状态码
  - HTTP每个对象封装在各自的响应报文中
  - SMTP多个对象包含在一个报文中
- 邮件报文格式
  - 首部行
    - To；
    - From；
    - Subject；
  - 主体
    - 报文。只能是ASCII码字符
  - 多媒体扩展： MIME
- 邮件访问协议
  ![邮件访问流程](Email_Access_Process.png "邮件访问流程")

### POP3

- 本地管理文件夹
- 邮局访问协议 - 在会话中是无状态的

  - 用户确认阶段
    - 客户端命令：
      - user：申明用户名
      - pass：口令
    - 服务器响应：
      - OK
      - ERR
  - 事务处理阶段：
    - 客户端
      - list：报文号列表
      - retr：根据报文号检索报文
      - dele：删除
      - quit

### IMAP

- 远程管理文件夹
- Internet邮件访问协议

  - IMAP服务器将每个报文与一个文件夹联系起来
  - 允许用户用目录来组织报文
  - 允许用户读取报文组件
  - IMAP在会话过程中保留用户状态：
    - 目录名、报文ID与目录名之间映射

## DNS

- 基础性系统
- 必要性

  - 域名到IP地址的转换
  - 服务器/主机别名到规范名字的转换
  - 负载均衡
- DNS系统

  - 运行在UDP之上端口号为53的应用服务
  - 核心的Internet功能，但以应用层协议来实现--在网络边缘处理复杂性
  - 如何命名---层次化命名

    - 一个层命名设备会有很多重名
    - DNS采用层次树状结构的命名方法
      - 域名
        - 从本域往上，直到树根
        - 中间使用 ''.'' 间隔不同的级别，如 ustc.edu.cn
        - 域的域名：可以用于表示一个域
        - 主机的域名：一个域上的一个主机
    - Internet根被划为几百个顶级域(top level domains)
      - 通用的 ---- .com  .edu .gov
      - 国家的 ---- .cn .us
      - 每个(子)域下面可划分为若干子域
      - 树叶是主机
      - 13个根名字服务器
    - 名字到IP地址的转换---通过分布式的数据库维护和响应名字查询来完成
    - 域的管理
      - 一个域管理其下的子域，创建一个新的域，必须征得它所属域的同意
      - 域与物理网络无关
        - 域遵从组织界限，而不是物理网络
          - 一个域的主机可以不做一个网络
          - 一个网络的主机不一定在一个域
        - 域的划分是逻辑的，不是物理的
  - 如何转换--名字服务器

    - 一个名字服务器的问题
      - 可靠性：单点故障
      - 扩展性：通信容量
      - 维护：远距离的集中式数据库
    - 区域
      - 区域的划分有区域管理员决定
      - 将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分
      - 名字服务器：

        - 每个区域都有一个名字服务器：维护着它所管辖区域的权威信息（权威名字服务器：组织机构的DNS服务器，提供组织机构服务器可访问的主机和IP之间的映射，组织机构可以选择实现自己维护或由某个服务提供商来维护）
        - 名字服务器允许被放置在区域之外，以保障可靠性
        - TLD服务器----顶级域(TLD)服务器：负责顶级域和所有国家级的顶级域名
        - 资源记录
          - 作用：维护 域名 - IP地址的映射关系
          - 位置：名字服务器的分布式数据库中
        - RR格式
          - TTL：time to live  生存时间，缓存：为了效率；删除为了一致性
          - Domain_name : 域名（www.baidu.com）
          - Class：对于Internet，值为IN
          - Value：可以是数字，域名或ASCII串(域名对应的IP地址)
          - Type：资源记录的类型，标示作用
            - A：name为主机，Value为IP地址
            - CNAME：Name为规范名字的别名，value为规范名字
            - NS：Name为域名，value为该域名的权威服务器的域名
            - MX：vlaue为name对应的邮寄服务器的名字
      - 过程：

        1. 应用调用解析器(resolver)
        2. 解析器作为客户向名字服务器发出查询报文(封装在UDP中)
        3. Name Server返回响应(name/ip)
           ![DNS解析过程](dns_resolver.png "DNS解析过程")

        - 本地名字服务器：
          - 并不严格属于层次结构
          - 每个ISP都有一个本地DNS服务器，也称默认名字服务器
          - 当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器--起代理作用，将查询转发到层次结构中
        - 名字解析过程：
          - 目标名字在local name server中
            1. 查询的名字在该区域内部
            2. 缓存
            3. 当本地名字服务器不能解析名字时，联系根名字服务器顺着根—TLD一直找到权威名字服务器

               - 递归查询：名字解析负担都放在当前联络的名字服务器上，根服务器的负担太重。可以使用迭代查询
               - 迭代查询：
                 1. 根(及各级域名)服务器返回的不是查询结果，而是下一个NS的地址
                 2. 最后由权威名字服务器给出解析结果
                 3. 当前联络的服务器给出可以联系的服务器(我不知道这个名字，但是可以向这个服务器联系)
        - 协议、报文
          - 报文首部：
            - 标识符(ID):16位
            - flags：
              1. 查询/应答
              2. 希望递归
              3. 递归可用
              4. 应答为权威
        - 提高性能：缓存
          - 一旦名字服务器学到了一个映射，就将该映射缓存起来
          - 根服务器通常都在本地服务器中缓存
            - 使得根服务器不用经常被访问
          - 可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致：解决方案----TTL(2天)
      - 维护：新增一个域

        - 在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址
        - 在新增子域的服务器上运行名字服务器，负责本域的名字解析： 名字->IP地址
      - 攻击DNS:

        - DDos攻击：
          - 对根服务器进行流量轰炸攻击：发送大量ping
            - 根目录服务配置里流量过滤器，防火墙
            - Local DNS 服务器缓存了TLD服务器的IP地址，因此无需查询根服务器
          - 向TLD服务器流量轰炸攻击：发送大量查询
            - 效果一般，大部分DNS缓存了TLD
        - 重定向攻击
          - 中间人攻击：截获查询，伪造回答，从而攻击某个站点
          - DNS中毒：发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果
          - 分布式解惑和伪造：技术上较困难
        - 利用DNS基础设施进行DDos
          - 伪造某个IP进行查询，攻击这个目标IP
          - 查询放大，响应报文比查询报文大

## P2P应用

- 优点：性能好、可扩展性好
- 缺点：可管理性差，高度的动态性
- 种类：非结构化P2P和DHT(结构化)P2P
  - 非结构化P2P：
    - 问题：
      1. 如何定位资源
      2. 如何管理节点
    - 方案：
      1. 集中式：客户端连接时上报IP、内容，下线时上报断开(集中式目录(Napster))
         - 存在单点故障
         - 性能瓶颈
         - 侵犯版权
      2. 分布式：Gnutella(查询泛洪)
         - 描述：
           1. 如果x和y之间有一个TCP连接，则二者之间存在一条边
           2. 所有活动的对等方和边就是覆盖网络
           3. 边不是物理链路
           4. 给定一个对等方，通常所连接的节点少于10个
         - 协议：
           - 在已有的TCP连接上发送查询报文(全部邻居)
           - 对等方转发查询报文
           - 以反方向返回查询命中报文
         - 建立：
           - 存在配置表，存有对等体列表
           - 对所有列表中的对等体发送ping，对等体接收到ping，同时会像自己的邻居转发这个ping
           - 收到这个ping的对等体都会回复这个加入的对等体发送pong
         - 问题：
           - 无限制的泛洪(设置TTL，有次数的查询)
      3. 混合式：KazaA(利用不匀称性)
         - 查询：
           - 每个文件有一个散列标识码和一个描述符
           - 客户端向其组长发送关键字查询
           - 组长用匹配进行响应
             - 对每个匹配：元数据、散列标识码和IP地址
           - 如果组长将查询转发给其他组长，其他组长也以匹配进行响应
           - 客户端选择要下载的文件
             - 向拥有文件的对等方发送一个带散列标识码的HTTP请求
      4. 案例：BitTorrent
         - 文件被分为一个个块256KB
         - bitmap去映射文件块
         - 网络中的这些peers发送接收文件块，相互服务
         - tracker:跟踪torrent中参与节点
         - 通过tracker server发现其他节点
         - Torrent（洪流）: 节点的组之间交换文件块
         - 上载带宽有限，选择几个节点进行疏通，一开始随机请求，之后稀缺优先
         - 优化疏通，每个周期评估节点，利己者优先。几个周期后再随机选择节点
  - 结构化P2P(DHT)
    - 哈希表
    - DHT方案
    - 环形DHT以及覆盖网络
    - Peer波动

## CDN

- 内容分发系统
- 解决问题：
  1. 大流量
  2. 大量用户
  3. 异构性
- 多媒体：视频：固定速度显示的图像序列
  - 编码：使用图像内和图像间的冗余来降低编码的比特数
    1. 空间冗余(图像内)
    2. 时间冗余(相邻的图像间)
  - CBR：以固定速率编码
  - VBR：视频编码速率随时间的变化而变化
  - 存储视频的流化服务：一边存储，一边看。
    - DASH：
      - 服务器：
        1. 将视频文件分割成多个块
        2. 每个块独立存储，编码于不同码率
        3. 告示文件：提供不同块的URL
      - 客户端：
        1. 先获取告示文件
        2. 周期性地测量服务器到客户端的带宽
        3. 查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围
           - 如果带宽足够，选择最大码率的视频块
           - 会话中的不同时刻，可以切换请求不同的编码块(取决于当时的可用带宽)
      - 客户端自适应决定
        - 什么时候请求块
        - 请求什么码率的视频块
        - 去哪里请求块
    - 存在问题：
      - 服务器到客户端路径上跳数较多，瓶颈链路的带宽小导致停顿
      - 二八规律决定了网络同时充斥着同一个视频的多个靠谱，效率低
      - 单点故障点，性能瓶颈
      - 周边网络的拥塞
    - 解决：通过CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务，缓解并发请求。
    - 位置：应用层，网络边缘 over the top(ott)
      - 存在问题：
        - 从哪个CDN节点获取内容-通过DNS，迭代查询
        - 用户在网络拥塞时的行为
        - 在哪些CDN节点中存储申明内容

## Socket

socket：分布式应用进程之间的门，传输层协议提供的端到端服务接口

### TCP编程

可靠的、字节流的服务

- 允许服务器与多个客户端通信
- 使用源IP和源端口来区分不同的客户端
- 数据结构sockaddr_in
  IP地址和port捆绑关系的数据结构(标示进程的端节点)

  ```c
  struct sockaddr_in{
    short sin_family; //地址簇 
    u_short sin_port; // port
    struct in_addr sin_addr; //IP地址
    char sin_zero[8]; //对齐
  }
  
  ```

- 数据结构hostent
  域名和IP地址的数据结构
  作为调用域名解析函数时的参数
  返回后，将IP地址拷贝到sockaddr_in的IP地址部分

  ```c
  struct hostent{
    char *h_name;//主机域名
    char **h_aliases;//二级指针，指向主机的别名  
    int h_addrtype;
    int h_length;//地址的长度
    char **h_addr_list;//ip地址列表
    #define h_addr h_addr_list[0];
  }
  ```

- 端口使用问题：
  - 一个端口只能被绑定一次，多个服务器进程不能绑定同一个端口
  - 被绑定的端口可以被多个进程共用
    ps： 如果进程先绑定一个端口号，然后在fork一个子进程，这样的话就可以是实现多个进程绑定一个端口号，但是两个不同的进程绑定同一个端口号是不可以的
  - 多个进程可以使用同一个端口进行发送和接收，这就是共用
  - 绑定不等于共用  
  
### UDP套接字编程

不可靠的服务，在客户端和服务器之间没有连接

- 没有握手
- 发送端在每一个报文中明确地指定目标的IP地址和端口号
- 服务器必须从收到的分组中提取出发送端的IP地址和端口号
- 传送的数据可能乱序，也可能丢失
- 用户数据报：传输层的UDP协议中的数据传输单元
- IP数据报：网络层的数据传输单元，又简称为数据报、分组或包
