---
title: KMP
date: 2021-09-17 16:55:50 
tags: 算法
---

# 介绍  

KMP算法是一种改进的字符串匹配算法。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。

<!-- more -->  

# 字符串匹配算法

给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模板串 P 在模式串 S中多次作为子串出现。

求出模板串 P 在模式串 S 中所有出现的位置的起始下标。

------

- 暴力算法：

```c++
int S[N],P[M];//S[n]是长字符串  P[N]是短字符串
for(int i = 1; i < n; i++)
{
    bool flag = true;
    for(int j = 1; j <= m; j++)
    {
        if(S[i] != P[i])
        {
            flag = false;
            break;
        }
    }
}
```

- KMP算法： KMP主要分两步：求next数组、匹配字符串

next[ ]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”。对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值）---“部分匹配值”：前缀和后缀的最长共有元素的长度。

**核心思想**：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的

```c++
#include<iostream>
using namespace std;
const int N = 10010, M = 100010;
int n, m;
char p[N], s[M];
int ne[N];
int main()
{
    cin >> n >> p+1 >> m >> s+1;
    //求next过程
    for(int i = 2, j = 0; i <= n; i++)
    {
        while(j && p[i] != p[j + 1]) j = ne[j];
        if(p[i] == p[j + 1]) j++;
        ne[i] = j;
    }
    //KPM匹配过程
    for(int i = 1, j = 0; i <= m; i++)
    {
        //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串
        //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)
        while(j && s[i] != p[j + 1]) j = ne[j];
        //当前元素匹配，j移向p串下一位
        if(s[i] == p[j + 1]) j++;
        if(j == n)
        {
            //匹配成功
            cout << (i - n) << ' ';
            j = ne[j];//继续匹配下一个子串
        }
    }
    return 0;
}
```

