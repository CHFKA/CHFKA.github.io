---
title: 栈与队列
date: 2021-09-16 14:11:59
tags: 算法
---

# 介绍  

用数组模拟栈与队列的操作；

<!-- more -->  

# 栈

实现一个栈，栈初始为空，支持四种操作：

1. `push x` – 向栈顶插入一个数 x；
2. `pop` – 从栈顶弹出一个数；
3. `empty` – 判断栈是否为空；
4. `query` – 查询栈顶元素。

现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。

------

实现：

```c++
#include<iostream>
using namespace std;
const int N = 1000010;
int stk[N] , tt;
void push(int x)
{
    stk[++tt] = x;
}
void pop()
{
    tt-- ;
}
bool isempty()
{
    if(tt > 0) return flase;
    else return true;
}
int query()
{
    return stk[tt];
}
```

## 单调栈

给定一个长度为 NN 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

实现：

```c++
#include<iostream>
using namespace std;
const int N = 1000010;
int stk[N] , tt;
int n;
int main()
{
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        while(tt && stk[tt] >= x) tt--;
        if(tt) cout << stk[tt] << endl;
        else cout << -1 << ' ';
        stk[++tt] = x;
    }
    return 0;
}
```



# 队列

实现一个队列，队列初始为空，支持四种操作：

1. `push x` – 向队尾插入一个数 xx；
2. `pop` – 从队头弹出一个数；
3. `empty` – 判断队列是否为空；
4. `query` – 查询队头元素。

现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。

------

实现：

```c++
#include<iostream>
using namespace std;
const int N = 1000010;
int q[N], hh, tt = -1;
void push(int x)
{
    stk[++tt] = x;
}
void pop()
{
    hh++ ;
}
bool isempty()
{
    if(hh > tt) return flase;
    else return true;
}
int query()
{
    return q[hh];
}
```

## 单调队列--滑动窗口

给定一个大小为 n≤1000000 的数组。

有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。

你只能在窗口中看到 k 个数字。

每次滑动窗口向右移动一个位置。

以下是一个例子：

该数组为 `[1 3 -1 -3 5 3 6 7]`，k 为 3。

|      窗口位置       | 最小值 | 最大值 |
| :-----------------: | :----: | :----: |
| [1 3 -1] -3 5 3 6 7 |   -1   |   3    |
| 1 [3 -1 -3] 5 3 6 7 |   -3   |   3    |
| 1 3 [-1 -3 5] 3 6 7 |   -3   |   5    |
| 1 3 -1 [-3 5 3] 6 7 |   -3   |   5    |
| 1 3 -1 -3 [5 3 6] 7 |   3    |   6    |
| 1 3 -1 -3 5 [3 6 7] |   3    |   7    |

你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

------

实现：

```c++
#include<iostream>
using namespace std;
const int N = 1000010;
int n, k;
int a[N], q[N]; // q[n]存的是下标
int main()
{
    scanf("%d%d", &n,&k);
    for(int  i = 0; i < n; i++) scanf("%d", &a[i]);
    int hh = 0, tt = -1;
    for(int i = 0; i < n; i++)
    {
        //判断队头是否已经滑出窗口
        //当队列不为空(hh <= tt) 且 当当前滑动窗口的大小(i - q[hh] + 1)>我们设定的滑动窗口的大小(k)
        //队列弹出队列头元素以维持滑动窗口的大小
        if(hh <= tt && i - q[hh] + 1 > k) hh++;
        //构造单调递增队列
        //当队列不为空(hh <= tt) 且 当队列队尾元素>=当前元素(a[i])时,
        //那么队尾元素就一定不是当前窗口最小值,删去队尾元素,加入当前元素(q[ ++ tt] = i)
        while(hh <= tt && a[q[tt]] >= a[i]) tt--;
        q[++tt] = i;
        if(i >= k - 1) printf("%d", a[q[hh]]);
        
    }
    puts("");
    
    hh = 0, tt = -1;
    for(int i = 0; i < n; i++)
    {
        //判断队头是否已经滑出窗口
        if(hh <= tt && i - q[hh] + 1 > k) hh++;
        while(hh <= tt && a[q[tt]] <= a[i]) tt--;
        q[++tt] = i;
        if(i >= k - 1) printf("%d", a[q[hh]]);
    }
    
    return 0;
}
```

