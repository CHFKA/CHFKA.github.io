---
title: 高精度
date: 2021-07-20 12:08:12
tags: 算法
---

# 介绍  

​	

<!-- more -->  

# 高精度

## 类型

- 两个较大整数相加
- 两个较大整数相减
- 一个较大整数乘以比较小的数
- 一个较大整数除以比较小的数

## 计算-加法

- 存储--用数组存储 （小端） 个为存在数组[0]的位置
- 单个加，逢十进一

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<int> add(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    int t = 0;
    for(int i = 0; i < A.size() || i < B.size(); i++)
    {
        if(i < A.size()) t += A[i];
        if(i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10; 
    }
    
    if(t) C.push_back(1);
    return C;
}

int main()
{
	string a, b;
	vector<int>A,B;
	
	cin >> a >> b;
	for(int i = a.size() - 1; i>= 0; i--) A.push_back(a[i] - '0');
	for(int i = b.size() - 1; i>= 0; i--) B.push_back(b[i] - '0');
    
    auto C = add(A,B);
    for(int i = C.size() -1; i >= 0; i--) printf("%d",C[i]);
    return 0;
}
```

## 计算-减法

```c++
#include <iostream>
#include <vector>
using namespace std;

bool cmp(vector<int> &A, vector<int> &B)
{
    if(A.size() != B.size()) return A.size() > B.size();
    for(int i = A.size() - 1; i >= 0; i--)
    {
        if(A[i] != B[i])
            return  A[i] > B[i];
    }
    return true;
}

vector<int> sub()(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for(int i = 0; t = 0; i < A.size(); i++)
    {
        t = A[i] - t;
        if(i < B.size())  t -= B[i];
        C.push_back((t + 10) % 10);
        if(t < 0) t = 1;
        else t = 0;
	}
   	while(C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main()
{
	string a, b;
	vector<int>A,B;
	
	cin >> a >> b;
	for(int i = a.size() - 1; i>= 0; i--) A.push_back(a[i] - '0');
	for(int i = b.size() - 1; i>= 0; i--) B.push_back(b[i] - '0');
    if(cmp(A,B))
    {
        auto C = sub(A,B);
    	for(int i = C.size() -1; i >= 0; i--) printf("%d",C[i]);
    }
    else
    {
        auto C = sub(B,A);
        printf("-");
        for(int i = C.size() -1; i >= 0; i--) printf("%d",C[i]);
    }
    
    return 0;
}
```

## 计算-乘法

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<int> mul(vector<int> &A, int b)
{
   	vector<int> C;
    int t = 0;
    for(int i = 0; i < A.size() || t; i++)
    {  
        if(i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while(C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main()
{
	string a;
    int b;
	vector<int>A;
	
	cin >> a >> b;
	for(int i = a.size() - 1; i>= 0; i--) A.push_back(a[i] - '0');
	
    
    auto C = mul(A,b);
    for(int i = C.size() -1; i >= 0; i--) printf("%d",C[i]);
    return 0;
}
```

## 计算-除法

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> div(vector<int> &A, int b, int &r)//r传入r的地址，便于直接对余数r进行修改
{
   	vector<int> C;
    r = 0;
    for(int i = A.size() - 1; i >= 0; i--)//对A从最高位开始处理
    {  
        r = r * 10 + A[i];//将上次的余数*10在加上当前位的数字，便是该位需要除的被除数
        C.push_back(r / b);//所得即为商在这一位的数字
        r %= b;
    }
    //由于在除法运算中，高位到低位运算，因此C的前导零都在vector的前面而不是尾部，vector只有删除最后一个数字pop_back是常数复杂度，而对于删除第一位没有相应的库函数可以使用，而且删除第一位，其余位也要前移，
    //因此我们将C翻转，这样0就位于数组尾部，可以使用pop函数删除前导0
    reverse(C.begin(), C.end());
    while(C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main()
{
	string a;
    int b;
	vector<int>A;
	
	cin >> a >> b;
	for(int i = a.size() - 1; i>= 0; i--) A.push_back(a[i] - '0');
	
    int r;
    auto C = div(A,b,r);
    for(int i = C.size() -1; i >= 0; i--) printf("%d",C[i]);
    cout << endl <<r << endl; 
    return 0;
}
```

