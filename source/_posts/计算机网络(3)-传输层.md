---
title: 计算机网络(3)-传输层
date: 2022-11-03 22:00:59
tags: 计算机网络
---
## 概述

- 理解传输层的工作原理

  - 多路复用/解复用
  - 可靠数据传输
  - 流量控制
  - 拥塞控制
- 学习Internet的传输层协议

  - UDP：无连接传输
  - TCP：面向连接的可靠传输
  - TCP的拥塞控制

<!-- more -->

## 传输层服务

- 为运行在不同主机上的应用进程提供逻辑通信
- 传输协议运行在端系统
  - 发送方：将应用层的报文分成报文段，然后传递给网络层
  - 接收方：将报文段重组成报文，然后传递给应用层
- 有多个传输层协议可供应选择：TCP和UDP
- 进程间的逻辑通信
  - 依赖于网络层的服务--带宽、延时
  - 并对网络层的服务进行增强
    - 数据丢失、顺序混乱、加密
- 协议
  - TCP
    - 多路复用、解复用
    - 拥塞控制
    - 流量控制
    - 建立连接
  - UDP
    - 多路复用、解复用
    - 没有尽力而为的为IP服务添加更多的其他额外服务
  - 都不提供的服务
    - 延时保证
    - 带宽保证

## 多路复用与解复用

复用：多个应用层协议使用一个传输层传递数据
解复用：一个传输层把不同的数据正确交付给不同应用

- 发送方多路复用
  从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装(该头部信息用于以后的解复用)
- 接收方多路解复用
  根据报文段的头部信息中的IP地址和端口号将接受到的报文段给正确的套接字(和对应的应用进程)
- UDP的多路复用与解复用
  - 用二元组标示(目标IP、目标端口号)
  - 如果两个不同源IP地址/源端口号，但是有**相同的目标IP地址和端口号**，则被定位相同的套接字
- TCP的多路复用与解复用
  - 四元组标示：源IP地址、源端口号、目的IP地址、目的端口号
  - Web服务器对每个连接客户端有不同的套接字
    - 非持久对每个请求有不同的套接字
    - 多线程Web服务器：
      1. 一个进程下下面可能多个线程：由多个线程分别为客户提供服务
      2. 根据4元组决定将报文段内容发到同一个进程下不同的线程
      3. 解复用到不同的线程

## UDP

UDP:User Datagram Protocol

- “尽力而为”的服务，报文段可能丢失、送到应用进程的报文段乱序
- 无连接：

  - 没有握手
  - 每个UDP报文段都被独立的处理
- 使用

  - 流媒体
  - DNS
  - SNMP
- 在UDP上实现可靠传输

  - 在应用层增加可靠性
  - 应用特定的差错恢复
- 用户数据报协议

  <div style="text-align: center;">
  <table border="1">
  <tr>
     <td>源端口号</td>
     <td>目的端口号</td>
  </tr>
  <tr>
     <td>长度</td>
     <td>校验和</td>
  </tr>
  <tr>
     <td colspan="2">应用程序数据(报文)</td>
  </tr>
  </table>
  </div>

- UDP的必要性

  - 不建立连接
  - 简单：没有连接的状态
  - 报文段的头部很小(开销小)
  - 无拥塞控制和流量控制
    UDP可以尽可能快的发送报文段
    应用->传输速率 = 主机 -> 网络的速率
- UDP校验和

  - 目标：检测在被传输报文中的差错(如比特反转)
  - 发送方：
    - 将报文段的内容视为16比特的整数
    - 校验和：报文段的加法和(1的补运算)
    - 发送方将校验和放在UDP的校验和字段
  - 接收方
    - 计算接收到的报文段的校验和
    - 检查计算出的校验和与校验和字段的内容是否相等
      - 不相等--检测到差错
      - 相等--可能有差错：残存错误
- 校验和

  - 当数字相加时，在最高位的进位要回卷，再加到结果上
  - 目标端：校验范围+校验和 = 1111 1111 1111 1111 通过校验
  - 求和时，必须将进位回卷到结果上

## 可靠数据传输(RDT)的原理

信道的不可靠特点决定了可靠数据传输协议(rdt)的复杂性

双向的数据传输问题实际上是2个单向数据传输问题的综合

### 具有比特差错的信道

具有比特差错的信道
下层信道可能会出错：将分组中的比特翻转。需要用校验和来检测比特差错

#### RDT2.0

- 确认(ACK):接收方显式地告诉发送方分组已被正确接收
- 否定确认(NAK)：接收方显示地告诉发送方分组发生了差错
  - 发送方收到NAK后，发送方重传分组
- 采用差错控制编码进行差错检测
  - 发送方差错控制编码、缓存
  - 接收方使用编码检错
  - 接收方的反馈：控制报文(ACK, NAK):接收方->发送方
  - 发送方收到反馈相应的动作
- 接收方不知道他最后发送的ACK/NAK是否被正确地收到
  - 发送方不对收到的ack/nak给确认，**没有所谓的确认的确认**
  - 接收方发送ack，如果后面接收方收到的是：
    - 重复分组。则ack错误
    - 下一个分组，ack正确

#### RDT2.1---序号

- 处理重复
  - 发送方在每个分组中加入序号
  - 如果ACK/NAK出错，发送方重传当前分组
  - 接收方丢弃重复分组
- 停等协议
  接收方发送一个分组，然后等待接收方的应答

#### RDT2.2---无NAK确认

- 只使用ACK(ack要编号)
- 接收方对最后正确接收的分组发ACK，以替代NAK
  - 接收方必须显式地包含正确接收分组的序号
- 当重复收到ACK时，发送方与收到NAK采取相同的动作：重传当前分组
- 为后面的一次发送多个数据单位做准备
  - 一次能够发送多个
  - 使用对前一个数据单位的ACK，代替本数据单位的NAK
  - 确认信息减少一半，协议处理简单

### 具有比特差错和分组丢失的信道

下层信道可能会丢失分组(数据或ACK)；会死锁

#### RDT3.0

发送方等待ACK一段合理的时间

- 发送端超时重传：如果到时没有收到ACK-> 重传
- 当分组(或ACK)只是被延迟了，接收方必须指明被正确接收的序号
- 需要一个倒计数定时器
- 在信道容量比较大的时候，利用率比较低(缺点)
  $$
  U_{sender} = \frac{L/R}{RTT+L/R}
  $$

#### RDT3.1

- 流水线协议：允许发送方在未得到接收方确认的情况下一次发送多个分组
  $$
  U_{sender} = \frac{N*L/R}{RTT+L/R}
  $$

  - 必须增加序号的范围：用多个bit表示分组的序号
  - 在发送方/接收方要有缓冲区
    - 发送方缓冲：未得到确认，可能需要重传
    - 接收方缓存：上层用户取用数据的速率$\ne$接收到的数据速率；接收到的数据可能乱序，排序交付(可靠)
  - 两种通用的流水线协议：回退N步(GBN)和选择重传(SR)

##### GO-back-N

- 发送端最多在流水性中有N个未确认的分组
- 接收端只是发送累计型确认：接收端如果分线gap，不确认新到来的分组
- 发送端拥有对最老的未确认分组的定时器
  - 只需设置一个定时器
  - 当定时器到时，重传所有未确认分组
- 只发送ACK：对顺序接收的最高序号的分组
  - 可能会产生重复的ACK
  - 接收窗口=1
- 对于乱序的分组
  - 丢弃-> 在接收方不被缓存
  - 对顺序接收的最高序号的分组进行确认-累计确认
- 例子
  ![GO-back-N](GBN_example.png "GO-back-N过程")

##### Selective Repeat

- 发送端最多在流水线中有N个未确认的分组
- 接收方对每个到来的分组单独确认
- 发送方为每个未确认的分组保持一个定时器：当超时定时器到时，只是重发到时的未确认分组
- 接收方对每个正确接收的分组，分别发送$ACK_{n}$(非累计确认)
  - 接收窗口>1:可以缓存乱序的分组
  - 最终将分组按顺序交付给上层
- 发送方只对那些每有收到ACK的分组进行重传-选择性重传
  - 发送方为每个未确认的分组设定一个定时器
- 发送窗口的最大值限制未确认分组的个数
- 例子
  ![SR](SR_example.png "SR过程")

##### 对比GBN和SR

|   名称   |GBN   | SR |
| ---- | ---- | ---- |
|   优点   |  简单，所需资源少    |   出错时重传一个代价小   |
|   缺点   |  一旦出错，回退N步代价大    |   复杂，所需资源多   |

- 适用范围
  - 出错率低：比较适合GBN。
  - 链路容量大，比较时候SR。

##### 滑动窗口(slide window)协议

- 发送缓冲区：

  - 形式：内存中的一个区域，落入缓冲区的分组可以发送
  - 功能：用于存放已发送，但是没有得到确认的分组
  - 必要性：需要重发时可用
- 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组

  - 停止等待协议=1
  - 流水线协议>1, 不能很大，链路利用率不能超过100%
- 发送缓冲区的分组：

  - 未发送的：落入发送缓冲区的分组，可以连续发送出去；
  - 已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除
- 发送窗口：发送缓冲区内容的一个范围

  - 已发送但未经确认分组的序号构成的空间
  - 发送窗口的移动：
    - 后沿移动：收到老分组的确认，可以向前移动，但不能超过前沿
- 接收窗口：
  接收窗口=接收缓冲区

  - 接收窗口用于控制哪些分组可以接收：
    - 只有收到的分组序号落入接收窗口内才允许接收
    - 若序号在接收窗口之外，丢弃
  - 接收窗口尺寸Wr=1，顺序接收
  - 接收窗口尺寸Wr>1，可以乱序接收
    - 但提交给上层的分组，要按序
  - 接收窗口的滑动和发送确认
    - 滑动：
      - 低序号分组到来，接收窗口移动
      - 高序号分组乱序到来，缓存到不交付，不滑动
    - 发送确认
      - 接收窗口尺寸=1，发送连续收到的最大的分组确认(累计确认)
      - 接收窗口尺寸>1, 收到分组，发送那个分组的确认(非累计确认)
- 发送接收窗口互动

  - 发送窗口
    - 有新的分组落入发送缓冲区，发送->前沿移动
    - 来了老的低序号分组的确认-> 后沿向前滑动-> 新的分组可以落入发送缓冲区的范围
  - 接收窗口
    - 收到分组，落入到接收窗口，接收
    - 是低序号，发送确认给对方
  - 发送端上面来了分组->发送窗口滑动->接收窗口滑动->发确认

##### 窗口的最大尺寸

- GBN：$2^{n}-1$
- SR: $2^{n-1}$

## TCP

- 概述
  - 点对点：一个发送，一个接收
  - 可靠的、按顺序的：没有报文边界
  - 管道化：TCP拥塞控制和流量控制设置窗口大小
  - 发送和接收缓存：
  - 全双工：
    - 在同一个连接中数据流双向流动
    - MSS：最大报文端大小
  - 面向连接：在数据交换之前，通过握手(交换控制报文)初始化发送方、接收方的状态变量
  - 有流量控制：发送方不会淹没接收方

### 段结构

<div class="center">
  <table style="text-align: center;border:0; cellpadding:0 cellspacing:0" >
  <tr>
    <td>源端口号</td>
    <td>目的端口号</td>
  </tr>
  <tr>
    <td colspan="2">序号</td>
  </tr>
  <tr>
    <td colspan="2">确认号</td>
  </tr>
  <tr>
    <td style="padding:0;">
    <table style="margin:0">
      <tr>
      <td width="32">首部长度</td>
      <td width="32">保留未用 </td>
      <td width="5">U</td>
      <td width="5">A</td>
      <td width="5">P</td>
      <td width="5">R</td>
      <td width="5">S</td>
      <td width="5">F</td>
      </tr>
    </table>
    </td>
    <td>接收窗口</td>
  </tr>
  <tr>
  <td title="t">校验和</td>
  <td>紧急数据指针</td>
  </tr>
  <tr>
  <td colspan="2">可选项</td>
  </tr>
  <tr>
  <td colspan="2">应用层数据<br>(长度可变)
  </td>
  </tr>
  </table>
</div>

- 报文段结构：
  - 序号：报文段首字节在字节流的编号
  - 确认号：
    - 期望从另一方收到的下一个字节的序号
    - 累积确认
  - 序号、确认号组合能够对字节计数
  - U：URG 紧急数据(通常不用)
  - A：ACK 合法确认
  - P：PSH 马上推出数据(通常不用)
  - R，S，F：RST，SYN，FIN 建立/拆除连接
  - 接收窗口：愿意接收的字节数量
  - 校验和：同UDP
- TCP往返延时(RTT)和超时
  - 往返延时(RTT)
    - SampleRTT：测量从报文段发出到收到确认的时间
      - 如有重传，忽略此次测量
    - SampleRTT会变化，因此估计的RTT应该比较平滑--求最近的平均值
    - EstimatedRTT = (1 - $\alpha$) $*$ EstimatedRTT + $\alpha$ $*$  SampleRTT
      - 指数加权移动平均
      - 过去样本的影响呈指数衰减
      - 推荐值 $\alpha$ = 0.125
  - 超时
    - EstimatedRTT + 安全边界时间
      - EstimatedRTT变化大(方差大)-> 较大的安全边界时间
    - SampleRTT会偏离EstimatedRTT多远：
  
      DevRTT = (1-$\beta$) $*$ DevRTT+ $\beta$ $*$ |SampleRTT - EstimatedRTT|
      - 推荐值：$\beta$ = 0.25
    - 超时时间间隔设置为：

      TimeoutInterval = EstimatedRTT + 4 $*$ DevRTT

### 可靠数据传输

- TCP在IP不可靠服务的基础上建立了RDT
  - 管道化的报文段：GNB 或 SR
  - 累计确认
  - 单个重传定时器
  - 是否可以接受乱序的，没有规范
- 触发重传
  - 超时:只重复那个最早的未确认段
  - 重复的确认
- TCP发送方：
  - 用nextseq创建报文段
  - 序号nextseq为报文段首字节的字节流编号
  - 如果还没有运行，启动定时器
    - 定时器与最早未确认的报文段关联
    - 过期间隔： TimeOutInterval
  - 超时：
    - 重传后沿最老的报文段
    - 重新启动定时器
  - 收到确认
    - 如果时对尚未确认的报文段确认
      - 更新已被确认的报文序号
      - 如果当前还有未被确认的报文段，重新启动定时器
- TCP：重传  
  ![TCP：重传](TCP_retransmission.png "TCP：重传")
- TCP接收方  
  ![TCP接收方事件](TCP_Receiver.png "TCP接收方事件")
- 快速重传
  - 超时周期太长：
    - 在重传丢失报文之前的延时太长
  - 通过重复的ACK来检测报文段丢失
    - 发送方通常连续发送大量报文段
    - 如果报文段丢失，通常会引起多个重复的ACK
  - 快速重传：在定时器过时之前重发报文段  
  ![TCP快速重传](TCP_Fast_retransmission.png "TCP快速重传")

### 流量控制

接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出

- 接收方在其发送方的TCP段头部的rwnd字段通告其空闲buffer大小

  - RcvBuffer大小通过socket选项设置(典型默认大小为4096字节)
  - 很多操作系统自动调整RcvBuffer
- 发送方限制未确认字节的个数 $\le$ 接收方发送过来的rwnd值
- 缓存中的可用的空间 = RcvWindow = RcvBuffer - [LastByteRcvd - LastByteRead]

### 连接管理

- 2次握手存在的问题
  - 变化的延迟(连接请求的段没有丢，但可能超时)
  - 由于丢失造成的重传
  - 报文乱序
  - 相互看不到对方
  ![2次握手](2nd_handshake.png "2次握手")
- 3次握手： 变化的初始序号+双方确认对方的序号  
  解决半连接和接收老数据问题  
  ![3次握手](3rd_handshake.png "3次握手")
- 关闭连接
  - 客户端和服务器分别关闭它自己这一侧的连接
    - 发送FIN bit = 1的TCP段
  - 一旦接收到FIN，用ACK回应
    - 接到FIN段，ACK可以和它自己发出的FIN段一起发送
  - 可以处理同时的FIN交换
  - TCP关闭连接并不完美  
  
  ![关闭连接](close_TCP.png "关闭连接")

## 拥塞控制原理

### 拥塞

- 非正式的定义： 太多的数据需要网络传输，超过了网络的处理能力
- 与流量控制不同
- 表现：
  1. 分组丢失(路由器缓冲区溢出)
  2. 分组经历比较长的延迟(在路由器的队列中排队)

#### 原因

- 为了达到一个有效输出，网络需要做更多的工作(丢失后重传)
- 没有必要的重传，链路中包括了多个分组的拷贝
  - 是那些没有丢失，经历的时间比较长(拥塞状态)但是超时的分组
  - 降低了的'goodput'(有效吞吐量)
- 当分组丢失时，任何"关于这个分组的上游传输能力"都被浪费了

### 拥塞控制方法

- 端到端拥塞控控制方法
  - 没有来自网络的显式反馈
  - 端系统根据延迟和丢失事件推断是否有拥塞
  - TCP采用
- 网络辅助的拥塞控制 -路由器提供给端系统以反馈信息
  - 单个bit置位，显示有拥塞(SNA,DECbit,TCP/IP ECN, ATM)
  - 显式提供发送端可以采用的速率

## TCP拥塞控制

### 机制

- 路由器不向主机有关拥塞的反馈信息
  - 路由器的负担较轻
  - 符合网络核心简单的TCP/IP架构原则
- 端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作
- 拥塞程度判断
  - 某个段超时了(丢失事件):拥塞
    - 一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的
  - 有关某个段的3次重复ACK:轻微拥塞
- 拥塞控制：速率控制方法
  - 维持一个拥塞窗口的值:CongWin
  - 发送端限制已发送但是未确认的数据量(的上限):  
      $LastByteSent - LastByteAcked \le CongWin$hh
  - 速率：  
    $rate \approx \frac{CongWin}{RTT}bytes/sec$