---
title: 哈希表 
date: 2021-09-24 22:48:33 
tags: 算法
---

# 介绍  

普通的哈希表的存储结构，字符串的哈希方法.

<!-- more -->  

# 哈希表--期望算法

1. 存储结构
   - 开放寻址法
   - 拉链法
2. 字符串哈希方式

作用：把复杂的数据映射到简单数据。

## 拉链法

维护一个集合，支持如下几种操作：

1. `I x`，插入一个数 x；
2. `Q x`，询问数 x 是否在集合中出现过；

现在要进行 N 次操作，对于每个询问操作输出对应的结果。

------

实现：

```c++
#include<iostream>
#include <cstring>
using namespace std;

const int N = 100003;//一般取质数 100010  取质数冲突的概率最小

int h[N], e[N], ne[N], idx;//邻接表

void insert(int x)
{
    // x映射到 从 0-1e5 之间的数
    // c++中如果是负数 那他取模也是负的 所以 加 N 再 % N 就一定是一个正数
    int k = (x % N + N) % N;//映射为了让余数是正数
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx ++;
}

bool find(int x)
{
    int k = (x % N + N) % N;
    for(int i = h[k]; i != -1; i = ne[i])
        if(e[i] == x)
            return true;
    return false;
}

int main()
{
    int n;
    scanf("%d", &n);
    memset(h, -1, sizeof h); //将槽先清空 空指针一般用 -1 来表示
    while(n--)
    {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if(*op == 'I') insert(x);
        else
        {
            if(find(x)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

## 开放寻址法

- 只开了一个一维数组
- 开发范围是数据长度的2~3倍

```c++
#include<iostream>
#include <cstring>
using namespace std;
//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了
const int N = 200003 ;//取质数冲突的概率最小
const int null = 0x3f3f3f3f;//规定空指针为 null 0x3f3f3f3f
int h[N];



int find(int x)
{
    int k = (x % N + N) % N;//c++中如果是负数 那他取模也是负的 所以 加 N 再 % N 就一定是一个正数
	while(h[k] != null && h[k] != x)
    {
        k++;
        if(k == N) k = 0;
    }
    return k;
}

int main()
{
    int n;
    scanf("%d", &n);
    memset(h, 0x3f, sizeof h); //将槽先清空 空指针一般用 -1 来表示
    while(n--)
    {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        int k = find(x);
        if(*op == 'I') 
        {
            h[k] = x;
        }
        else
        {
            if(h[k] != null) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

# 字符串哈希--字符串前缀哈希法

**快速判断两个字符串是否相等的时候使用**

- 字符串看出P进制数

- 将字符串转换成数字 
- 再模上一个较小的数
- 前缀和公式$ h[i+1]=h[i]×P+s[i] ,i∈[0,n−1] $.h为前缀和数组，s为字符串数组
  区间和公式 $\mathbf{h[l,r]}=h[r]−h[l−1]×\mathbf{P^{r−l+1}}$
- 区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，
  乘上$ P^2$ 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。

注意：

- 不能把某个字母映射成0
- 不考虑冲突

------

给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1]和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。

字符串中只包含大小写英文字母和数字。

------

实现：

```c++
#include<iostream>
using namespace std;

typedef unsigned long long ULL;

const int N = 100010, P = 131;
// h[i]前i个字符的hash值
// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字
// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突
int n,m;
char str[N];
ULL h[N],p[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf("%d%d%s", &n, &m, str+1);
    p[0] = 1;
    //前缀和
    for(int i = 1; i <= n; i++)
    {
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i];
    }
    while(m--)
    {
        int l1, r1, l2, r2;
    	scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
        if(get(l1,r1) == get(l2,r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

