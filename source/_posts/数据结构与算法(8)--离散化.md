---
title: 离散化
date: 2021-08-6 14:17:53
tags: 算法
---

# 介绍  

​	特指整数有序的离散化

假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。

现在，我们首先进行 n次操作，每次操作将某一位置 x 上的数加 c。

接下来，进行 m 次询问，每个询问包含两个整数 l和 r，你需要求出在区间 [l,r] 之间的所有数的和。

<!-- more -->  

## 离散化

- 含义：把无限空间中有限的个体映射到有限的空间中去
- 目标：在不改变数据相对大小的条件下，对数据进行相应的缩小
- 注意：
  - 有重复元素需要去重。
  - 如何去算离散化后的值----二分

------

假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。

现在，我们首先进行 n次操作，每次操作将某一位置 x 上的数加 c。

接下来，进行 m 次询问，每个询问包含两个整数 l和 r，你需要求出在区间 [l,r] 之间的所有数的和

------

实现：

```c++
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;
typedef pair<int, int> PII; 

const int N = 300010;

int n,m;
int a[N],s[N];

vector<int> alls;
vector<PII>add,query;

int find(int x)
{
    int l = 0, r = alls.size()-1;
    while(l < r)
    {
        int mid = ( l + r ) / 2;
        if(alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r+1;
}

vector<int>::iterator unique(vector<int> &a)
{
    int j = 0;
    for(int i = 0; i < a.size(); i++)
    {
        if(!i || a[i] != a[i-1])
          a[j++] = a[i];
        //a[0] ~ a[j-1] 所有a中不重复的数
    }
    return a.begin() + j;
}

int main()
{
    cin >> n >> m;
    for(int  i = 0; i < n; i++)
    {
        int x,c;
        cin >> x >> c;
        add.push_back({x, c});
        alls.push_back(x);
    }
    for(int i = 0; i < m; i++)
    {
        int l,r;
        cin >> l >> r;
        query.push_back({l,r});
        alls.push_back(l);
        alls.push_back(r);
    }
    //去重
    sort(alls.begin(),alls.end());
    
    //使用stl  alls.erase(unique(alls.begin(),alls.end()),alls.end());
    //使用自己编写的
    //处理插入unique
    alls.erase(unique(alls),alls.end());
    for(auto item : add)
    {
        int x = find(item.first);
        a[x] += item.second;
    }
    //预处理前缀和
    for(int i = 1; i <= alls.size(); i++) s[i] = s[i -1] + a[i];
    //处理查询
    for(auto item : query)
    {
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l-1] << endl;
    }
}

```

