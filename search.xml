<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++primer 指针学习</title>
    <url>/2020/12/02/C-primer%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p> 这篇是学习 C++piemer 后关于指针的笔记 </p>
<span id="more"></span>
<h2 id="指针"> 指针 </h2>
<ul>
<li> 指针是对其他对象的间接访问。与引用类似，却有很多不同
<ul>
<li> 指针本身是一个对象 </li>
<li> 无需在定义时赋初值 </li>
</ul></li>
<li> 解引用符的作用 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- <span class="keyword">int</span> *p；  此时 * 的作用是声明，声明 p 是一个指针。</span><br><span class="line">- *p = &amp;r;  此时 * 的作用是解引用，指向 p 所存地址的内容。</span><br></pre></td></tr></table></figure>
<ul>
<li> 初始化所有指针 </li>
</ul>
<h2 id="常量指针和指针常量"> 常量指针和指针常量 </h2>
<ul>
<li><p> 常量指针 </p>
<p> 常量指针即指针是一个常量，也就是说指针指向的地址是一个常量，不能改变。但是地址内所保存的值可以变。以下是常量指针的特点：</p></li>
<li><p> 指针常量 </p>
<p> 指针指向的对象是一个常量。这个常量不能被改变。以下是指针常量的特点：</p></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>库的制作与使用</title>
    <url>/2021/06/04/Linux(0)-1%E3%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​ 这是在 linux 环境下制作库和使用的过程。</p>
<span id="more"></span>
<h1 id="库制作与使用"> 库制作与使用 </h1>
<h2 id="静态库 ---.a 后缀名"> 静态库 ---.a 后缀名 </h2>
<h3 id="制作步骤"> 制作步骤 </h3>
<ul>
<li> 编译为.o 文件
<ul>
<li>gcc -c *.c -Iinclude/（头文件路径）</li>
</ul></li>
<li> 将.o 文件打包
<ul>
<li>ar rcs libCalc.a(库文件名) *.o</li>
<li>nm(命令) 查看文件信息 </li>
</ul></li>
<li> 将头文件与库一起发布 </li>
</ul>
<h3 id="使用"> 使用 </h3>
<ul>
<li> 编译时需要加静态库名 (记得路径)，-I 包含文件
<ul>
<li>gcc main.c -o app(执行文件名) -I include/(头文件路径) -L lib/(库文件路径) -lCalc(库文件名省去 lib)</li>
</ul></li>
</ul>
<h2 id="动态库 ---.so 后缀名"> 动态库 ---.so 后缀名 </h2>
<h3 id="制作步骤 -1"> 制作步骤 </h3>
<ul>
<li> 编译与位置无关的代码，生成.o，关键参数 -fPIC
<ul>
<li>gcc -fPIC -c *.c -I include/</li>
</ul></li>
<li> 将.o 文件打包 关键参数 -shared
<ul>
<li>gcc -shared -o libCalc.so *.o</li>
</ul></li>
<li> 将库与头文件一起发布 </li>
</ul>
<h3 id="使用 -1"> 使用 </h3>
<ul>
<li>-L 指定动态库路径 -l 指定库名
<ul>
<li>gcc main.c -o newapp(可执行文件名) -I include/(头文件路径) -L lib/(库文件路径) -lCalc(库名)</li>
</ul></li>
<li> 环境变量配置 -- 在执行时能找到动态库
<ul>
<li>ldd newapp(可执行文件名) 查看链接 </li>
<li> 拷贝到系统的库路径下（不推荐）</li>
<li> 使用 export LD_LIBRARY_PATH=(路径名):$LD_LIBRARY_PATH （不特别推荐使用）</li>
<li>1. 使用 sudo vim /etc/ld.so.conf 2. 在文件中配置共享库路径 3. 保存后输入 sudo ldconfig</li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 调试</title>
    <url>/2021/06/06/Linux(0)-2%E3%80%81GDB%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​ 这是在 linux 环境下使用 GDB 调试使用。</p>
<span id="more"></span>
<h1 id="gdb 调试">GDB 调试 </h1>
<h2 id="使用"> 使用 </h2>
<h3 id="命令"> 命令 </h3>
<ul>
<li> 编译时后缀 -g</li>
<li> 启动 ： gdb app（可执行程序名）
<ul>
<li>r(un) : 执行一遍程序
<ul>
<li>run (参数 1)...</li>
</ul></li>
<li>start: 执行到主程序前 </li>
<li>n(ext): 往下执行一步 </li>
<li>s(tep): 往下执行一步, 可以执行到函数内部，库函数不能进入 </li>
<li>q(uit): 退出 </li>
<li>set : 设置参数
<ul>
<li> 可以在调式过程中对程序参数设值，如循环变量 </li>
</ul></li>
<li>list 显示 10 代码 回车后继续显示 10 行
<ul>
<li>l 文件名: 行号 </li>
</ul></li>
<li>b(reak) (行数): 设置断点
<ul>
<li>b (函数名)：对单词所在行数设置断点 </li>
<li>b *.c:(行数)：可以指定文件 </li>
<li>info b 断点信息 </li>
<li>d (断点序号) ：删除断点 </li>
<li> 条件断点 b （行数） if（条件）</li>
</ul></li>
<li>c(ontinue)：继续执行 </li>
<li>p(rint) : 打印变量信息
<ul>
<li>ptype 查看变量类型 </li>
</ul></li>
<li>display (参数) ：追踪，变量变化时显示
<ul>
<li>info display 显示 display 设置信息 </li>
<li>undisplay：删除显示变量 </li>
</ul></li>
</ul></li>
</ul>
<h3 id="跟踪 core"> 跟踪 core</h3>
<ul>
<li> 设置生成 core：ulimit -c (大小设置)</li>
<li> 使用：gdp （可执行程序名） core
<ul>
<li>where 显示错误行数 </li>
</ul></li>
<li> 设置 core 文件在 /proc/sys/kernel/core_pattern
<ul>
<li>%e ---- 可执行程序名字 </li>
<li>%t ---- 添加 core 文件生成时的 unix 时间 </li>
</ul></li>
<li>echo ”core-%e-%t“&gt;/proc/sys/kernel/core_pattern
<ul>
<li> 需要权限 先获取权限 sudo （管理员名）</li>
<li>gdb （可执行程序名） core-(可执行程序名)-(unix 时间)</li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>编写 makefile</title>
    <url>/2021/06/05/Linux(0)-3%E3%80%81%E7%BC%96%E5%86%99makefile/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​ 这是在 linux 环境下编写 makefile 的要点和自己编写的例子。</p>
<span id="more"></span>
<h1 id="编写 makefile"> 编写 makefile</h1>
<h2 id="三要素"> 三要素 </h2>
<ul>
<li> 目标 </li>
<li> 依赖 </li>
<li> 规则命令 </li>
</ul>
<h2 id="写法"> 写法 </h2>
<h3 id="第一版"> 第一版 </h3>
<p> 目标：依赖 </p>
<p>tab 键 规则命令 </p>
<p>app(可执行文件) ： *.c</p>
<p>​ gcc -o app -I include/ *.c</p>
<ul>
<li> 缺点：如果更改其中一个文件是，所有的源码都重新编译 </li>
</ul>
<h3 id="第二版"> 第二版 </h3>
<ul>
<li><p> 定义变量 ---ObjFiles=*.o</p></li>
<li><p> 变量的使用 ---$(ObjFiles) $(变量名)</p></li>
<li><p>makefile 的隐含规则：默认处理第一个目标 </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ObjFiles=*.o</span><br><span class="line">app(可执行文件) :<span class="variable">$(ObjFiles)</span></span><br><span class="line">​	gcc -o  app -I <span class="keyword">include</span>/  *.o</span><br><span class="line">*.o： *.c（代表例子）</span><br><span class="line">​	gcc -c  *.c -I <span class="keyword">include</span>/</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第三版"> 第三版 </h3>
<h4 id="函数"> 函数 </h4>
<ul>
<li>wildcard 可以进行文件匹配 </li>
<li>patsubst 内容的替换 </li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get all .c files</span></span><br><span class="line">SrcFiles =<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#all .c files --&gt; .o files</span></span><br><span class="line">ObjFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line">app(可执行文件) :<span class="variable">$(ObjFiles)</span></span><br><span class="line">​	gcc -o  app -I <span class="keyword">include</span>/  <span class="variable">$(ObjFiles)</span></span><br><span class="line"></span><br><span class="line">*.o： *.c  （代表例子）</span><br><span class="line">​	gcc -c  *.c -I <span class="keyword">include</span>/</span><br></pre></td></tr></table></figure>
<h4 id="变量"> 变量 </h4>
<ul>
<li>$@ 代表目标 </li>
<li>$^ 代表全部依赖 </li>
<li>$&lt; 第一个依赖 </li>
<li>$? 第一个变换的依赖 </li>
<li>clean 清理命令
<ul>
<li><span class="citation" data-cites="不输出该条规则">@不输出该条规则 </span></li>
<li>’-‘ 报错后继续执行 </li>
</ul></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get all .c files</span></span><br><span class="line">SrcFiles =<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#all .c files --&gt; .o files</span></span><br><span class="line">ObjFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line">app(可执行文件) :<span class="variable">$(ObjFiles)</span></span><br><span class="line">​	gcc -o  app -I <span class="keyword">include</span>/  <span class="variable">$(ObjFiles)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配规则 </span></span><br><span class="line">%.o： %.c  （代表例子）</span><br><span class="line">​	gcc -c  <span class="variable">$&lt;</span>  -I <span class="keyword">include</span>/</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@rm -f *.o</span><br><span class="line">	rm -f app</span><br></pre></td></tr></table></figure>
<h3 id="第四版"> 第四版 </h3>
<ul>
<li>clean 存在歧义时 使用.PHONY</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get all .c files</span></span><br><span class="line">SrcFiles =<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#all .c files --&gt; .o files</span></span><br><span class="line">ObjFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:app</span></span><br><span class="line"></span><br><span class="line">app(可执行文件) :<span class="variable">$(ObjFiles)</span></span><br><span class="line">​	gcc -o app -I <span class="keyword">include</span>/  <span class="variable">$(ObjFiles)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式匹配规则 $&lt; 这样的变量只能在规则中 </span></span><br><span class="line">%.o： %.c  （代表例子）</span><br><span class="line">​	gcc -c  <span class="variable">$&lt;</span>  -I <span class="keyword">include</span>/</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean all</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@rm -f *.o</span><br><span class="line">	rm -f app</span><br></pre></td></tr></table></figure>
<h3 id="补充"> 补充 </h3>
<ul>
<li><p> 使用其他名字的 makefile</p>
<ul>
<li><p>make -f （文件名）</p></li>
<li><p> 例子 </p>
<figure>
<img src="/2021/06/05/Linux(0)-3%E3%80%81%E7%BC%96%E5%86%99makefile/makefile 例子.png" alt="makefile 例子"><figcaption aria-hidden="true">makefile 例子 </figcaption>
</figure></li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>进程控制</title>
    <url>/2021/06/05/Linux(0)-4%E3%80%81%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="文件 io"> 文件 IO</h1>
<h2 id="open">open</h2>
<ul>
<li><p> 查看 man 2 open</p>
<ul>
<li><p>pathname： 文件名 </p></li>
<li><p>flags</p>
<ul>
<li><p>O_RDONLY 只读 </p></li>
<li><p>O_WDONLY 只写 </p></li>
<li><p>O_RDWR 读写 </p></li>
<li><p> 可选项 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">O_RDWR|O_APPEND</span><br></pre></td></tr></table></figure>
<ul>
<li>O_APPEND 追加 </li>
<li>O_CREAT 创建文件
<ul>
<li>O_EXCL 与 O_CREAT 一起使用，如果文件存在，则报错 </li>
<li>mode 权限位，最终（mode&amp;~umask）</li>
</ul></li>
<li>O_NONBLOCK 非阻塞 </li>
</ul></li>
</ul></li>
<li><p> 返回值 ： 返回最小的可用文件描述符 失败返回 -1，设置 errno</p></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> cahr* pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> cahr* pathname, <span class="keyword">int</span> flags,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="close">close</h2>
<ul>
<li><p>```c int close() <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- fd open 打开的文件描述符 </span><br><span class="line"></span><br><span class="line">- 返回值：成功返回 0 失败返回 -1，设置 errno</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## read 读 </span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;c</span><br><span class="line">  ssize_t read(int fd, void* buf,size_t count);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>fd 文件描述符‘</li>
<li>buf 缓冲区 </li>
<li>count 缓冲区大小 </li>
<li> 返回值
<ul>
<li> 失败返回 -1，设置 errno</li>
<li> 成功返回读取到的大小 </li>
<li>0 代表读到文件末尾 </li>
<li> 非阻塞的情况下 read 返回 -1，但此时需要判断 errno 的值 </li>
</ul></li>
</ul></li>
</ul>
<h2 id="write 写">Write 写 </h2>
<ul>
<li>```c ssize_t read(int fd, void* buf,size_t count); <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - fd 文件描述符‘</span><br><span class="line">  - buf 缓冲区 </span><br><span class="line">  - count 缓冲区大小 </span><br><span class="line">  - 返回值 </span><br><span class="line">    - 失败返回 -1，设置 errno</span><br><span class="line">    - 成功返回写入的字节数 </span><br><span class="line">    - 0，代表未写入 </span><br><span class="line"></span><br><span class="line">- 实现一个 cat 功能：读文件，输出到标准输出 </span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;c</span><br><span class="line">  #include&lt;stdio.h&gt;</span><br><span class="line">  #include&lt;unistd.h&gt;</span><br><span class="line">  #include&lt;sys&#x2F;stat.h&gt;</span><br><span class="line">  #include&lt;sys&#x2F;types.h&gt;</span><br><span class="line">  #include&lt;fcntl.h&gt;</span><br><span class="line">  </span><br><span class="line">  int main(int argc, char *argv[])</span><br><span class="line">  &#123;</span><br><span class="line">      if(argc !&#x3D; 2)</span><br><span class="line">      &#123;</span><br><span class="line">          return -1;</span><br><span class="line">      &#125;</span><br><span class="line">          </span><br><span class="line">      int fd &#x3D; open(argc[1],O_RDONLY);</span><br><span class="line">      char buf[256];</span><br><span class="line">      while(ret)</span><br><span class="line">      &#123;</span><br><span class="line">          int ret &#x3D; read(fd, buf ,sizeof(buf));</span><br><span class="line">      </span><br><span class="line">     		write(STDOUT_FILENO, buf , ret);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      close(fd);</span><br><span class="line">      </span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="lseek--- 移动文件读写位置">lseek - 移动文件读写位置 </h2>
<h3 id="使用"> 使用 </h3>
<ul>
<li><p>off_t lseek(int fd, off_t offset,intg whence);</p>
<ul>
<li><p>fd 文件描述符 </p></li>
<li><p>offset 偏移量 </p></li>
<li><p>whence</p>
<ul>
<li>SEEK_SET 文件开始位置 </li>
<li>SEEK_CUR 当前位置 </li>
<li>SEEK_END 结尾 </li>
</ul></li>
<li><p> 返回值 </p>
<ul>
<li> 成功 返回当前位置到开始的长度 </li>
<li> 失败 返回 -1. 设置 errno</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> fd = open(argc[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">    write(fd,<span class="string">&quot;helloworld&quot;</span>,<span class="number">11</span>);</span><br><span class="line">    <span class="comment">// 文件读写位置此时到末尾 </span></span><br><span class="line">    <span class="comment">// 需要移动读写位置 </span></span><br><span class="line">    lseek(fd, <span class="number">0</span> , SEEK_SET);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret)&#123;</span><br><span class="line">        write(STDOUT_FILENO,buf,ret);<span class="comment">//STDIN_FILENO.STDERR_FILENO</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用"> 作用 </h3>
<ul>
<li><p> 移动文件读写位置 </p></li>
<li><p> 计算文件大小 </p>
<ul>
<li><p>```c #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;sys/stat.h&gt; #include&lt;sys/types.h&gt; #include&lt;fcntl.h&gt; int main(int argc, char *argv[]) {if(argc != 2) {return -1;} int fd = open(argc[1],O_RDONLY);</p>
<pre><code>int ret = lseek(fd,0,SEEK_END);

close(fd);

return 0;</code></pre>
<p>} <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 拓展文件 </span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;c</span><br><span class="line">    #include&lt;stdio.h&gt;</span><br><span class="line">    #include&lt;unistd.h&gt;</span><br><span class="line">    #include&lt;sys&#x2F;stat.h&gt;</span><br><span class="line">    #include&lt;sys&#x2F;types.h&gt;</span><br><span class="line">    #include&lt;fcntl.h&gt;</span><br><span class="line">    int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">        if(argc !&#x3D; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int fd &#x3D; open(argc[1],O_WDONLY|O_CREAT，0666);</span><br><span class="line">        </span><br><span class="line">        int ret &#x3D; lseek(fd,1024,SEEK_END);</span><br><span class="line">        &#x2F;&#x2F; 至少写一次才能保存拓展文件 </span><br><span class="line">        write(fd,&quot;a&quot;,1);</span><br><span class="line">        </span><br><span class="line">        close(fd);</span><br><span class="line">        </span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h2 id="阻塞的概念"> 阻塞的概念 </h2>
<ul>
<li><p>read 函数在读设备或者读管道，或者网络的时候发生阻塞现象 </p>
<ul>
<li><p>/dev/ttey 为输入输出设备对应文件 </p></li>
<li><p>```c #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;sys/stat.h&gt; #include&lt;sys/types.h&gt; #include&lt;fcntl.h&gt; int main(int argc, char *argv[]) {int fd = open("/dev/ttey",O_RDWR); char buf[256]; int ret = 0; while(1) {ret = read(fd, buf , sizeof(buf)); } return 0; } <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ​	可以在 open 的参数中加入可选项 O_NONBLOCK ，使得程序在读写时不阻塞。</span><br><span class="line"></span><br><span class="line">- fcntl 函数 </span><br><span class="line"></span><br><span class="line">  - 设置非阻塞 </span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;c</span><br><span class="line">    #include&lt;stdio.h&gt;</span><br><span class="line">    #include&lt;unistd.h&gt;</span><br><span class="line">    #include&lt;sys&#x2F;stat.h&gt;</span><br><span class="line">    #include&lt;sys&#x2F;types.h&gt;</span><br><span class="line">    #include&lt;fcntl.h&gt;</span><br><span class="line">    int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">        int fd &#x3D; open(&quot;&#x2F;dev&#x2F;ttey&quot;,O_RDWR);</span><br><span class="line">        </span><br><span class="line">        int flags &#x3D; fcntl(fd,F_GETFL);</span><br><span class="line">        flags |&#x3D; O_NONBLOCK;</span><br><span class="line">        fcntl(fd,F_GETFL,flags);</span><br><span class="line">        </span><br><span class="line">        char buf[256];</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">            ret &#x3D; read(fd, buf , sizeof(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    	return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程相关的概念</title>
    <url>/2021/06/07/Linux(1)-1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>​ 这是在 linux 环境下进程相关概念、要点。</p>
<span id="more"></span>
<h1 id="进程相关的概念">进程相关的概念</h1>
<h2 id="进程与程序">进程与程序</h2>
<ul>
<li>运行着的程序
<ul>
<li>操作 系统： 分配系统资源的基本单位</li>
<li>程序员： 运行一系列指令的过程</li>
</ul></li>
<li>区别
<ul>
<li>程序占用磁盘，不占用系统资源</li>
<li>内存占用系统资源</li>
<li>一个程序对应多个进程，一个进程对应一个程序</li>
<li>程序没有生命周期，进程有</li>
</ul></li>
</ul>
<h2 id="进程的状态">进程的状态</h2>
<ul>
<li><p>就绪 -- 获得 cpu</p></li>
<li><p>运行</p></li>
<li><p>挂起 -- 主动失去 cpu 或缺少执行的数据，获得数据或资源后成为就绪。</p></li>
<li><p>终止 --- 任何状态都能变换到终止</p></li>
</ul>
<h2 id="mmu 的作用 --- 内存管理单元">MMU 的作用 --- 内存管理单元</h2>
<ul>
<li><p>虚拟内存与物理内存的映射</p></li>
<li><p>设置修改内存访问级别</p></li>
<li><p>用户空间映射到物理空间是独立的</p></li>
</ul>
<h2 id="进程控制块 pcb">进程控制块 PCB</h2>
<p>​ 每个进程在内核都有一个进程控制块 (PCB) 来维护进程相关的信息，linux 内核的进程控制块是 task struct 结构体.</p>
<ul>
<li><p>进程 id</p></li>
<li><p>进程的状态</p></li>
<li><p>描述虚拟地址空间的信息</p></li>
<li><p>进程切换时需要保存和恢复的一些 CPU 寄存器</p></li>
<li><p>描述控制终端的信息</p></li>
<li><p>当前工作目录</p></li>
<li><p>umask 掩码</p></li>
<li><p>文件描述表</p></li>
<li><p>和信号相关的信息</p></li>
<li><p>用户 id 和组 id</p></li>
<li><p>会话和进程组</p></li>
<li><p>进程可以使用的资源上限</p></li>
</ul>
<h2 id="环境变量">环境变量</h2>
<ul>
<li><p>env 写法： key = val</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.bashrc  </span></span><br><span class="line"><span class="keyword">export</span> key = val;</span><br><span class="line"><span class="comment">// 获取环境变量</span></span><br><span class="line">getenv(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程控制</title>
    <url>/2021/06/07/Linux(1)-2%E3%80%81%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="进程"> 进程 </h1>
<h2 id="进程控制"> 进程控制 </h2>
<h3 id="fork 函数 - 创建分支进程">fork 函数 - 创建分支进程 </h3>
<ul>
<li><p> 函数名 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li> 返回值
<ul>
<li> 失败 -1</li>
<li> 成功返回两次
<ul>
<li> 父进程返回子进程的 id</li>
<li> 子进程返回 0</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="getpid 函数 - 获得当前进程的 id">getpid 函数 - 获得当前进程的 id</h3>
<ul>
<li><p> 函数名 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="getppid 函数 - 获得当前父进程的 id">getppid 函数 - 获得当前父进程的 id</h3>
<ul>
<li><p> 函数名 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="进程命令"> 进程命令 </h3>
<ul>
<li>ps
<ul>
<li>ps aux</li>
<li>ps ajx -- 可以追溯进程之间的血缘关系 </li>
</ul></li>
<li>kill
<ul>
<li> 给进程发送一个信号 </li>
<li>SIGKILL ９号信号 </li>
<li>kill -SIGKILL pid -- 杀死进程 </li>
</ul></li>
</ul>
<h3 id="例子"> 例子 </h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am child pid = %d ，ppid = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程共享"> 进程共享 </h2>
<ul>
<li><p> 读时共享，写时复制.</p></li>
<li><p> 全局变量不共享 </p></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>exec 函数族</title>
    <url>/2021/06/08/Linux(1)-3%E3%80%81exec%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="exec 函数族">exec 函数族 </h1>
<ul>
<li> 将当前进程的.text、.data 替换为所要加载的程序的.text、.data，然后让进程从新的.text 第一条指令开始执行，但进程 ID 不变，换核不换壳。</li>
</ul>
<h2 id="execl 函数">execl 函数 </h2>
<ul>
<li><p> 执行其他程序 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">const</span> <span class="keyword">char</span> *arg,...)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="excelp 函数">excelp 函数 </h2>
<ul>
<li><p> 执行程序的时候，使用 PATH 环境变量，执行的程序可以不用加路径 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file,<span class="keyword">const</span> <span class="keyword">char</span> *arg,...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>flie 要执行的程序 </li>
<li>arg 参数列表
<ul>
<li> 参数列表最后需要一个 NULL 作为结尾，作为哨兵。</li>
</ul></li>
<li> 返回值
<ul>
<li> 只有失败才返回 </li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="/2021/06/08/Linux(1)-3%E3%80%81exec%E5%87%BD%E6%95%B0/exce 函数族.png" alt="exce 函数族"><figcaption aria-hidden="true">exce 函数族 </figcaption>
</figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>子进程回收</title>
    <url>/2021/06/08/Linux(1)-4%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="子进程回收"> 子进程回收 </h1>
<h2 id="wait 函数">wait 函数 </h2>
<ul>
<li><p> 回收子进程，知道子进程的死亡原因 </p>
<ul>
<li>```c pid_t wait(int *status); <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - status 传出参数 </span><br><span class="line">    - 返回值 </span><br><span class="line">      - 成功返回终止的子进程 ID</span><br><span class="line">      - 失败返回 -1</span><br><span class="line"></span><br><span class="line">  - 作用：</span><br><span class="line"></span><br><span class="line">    - 阻塞等待 </span><br><span class="line">    - 回收子进程资源 </span><br><span class="line">    - 查看死亡原因 </span><br><span class="line"></span><br><span class="line">  - 死亡原因 </span><br><span class="line"></span><br><span class="line">    - 正常死亡 WIFEXITED</span><br><span class="line">      - 如果 WIFEXITED 为真，使用 WEXITSTATUS 得到退出状态 </span><br><span class="line">    - 非正常死亡 WIFSIGNALED</span><br><span class="line">      - 如果 WIFSIGNALED 为真，使用 WTERMSIG 得到信号 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## waitpid 函数 </span><br><span class="line"></span><br><span class="line">- pid_t waitpid(pid_t pid,int *status, int options);</span><br><span class="line"></span><br><span class="line">  - pid</span><br><span class="line"></span><br><span class="line">    - 小于 -1  组 id</span><br><span class="line">    - -1 回收任意 </span><br><span class="line">    - 0 回收和调用进程组 id 相同组内的子进程 </span><br><span class="line">    - 大于 0 回收指定的 pid</span><br><span class="line"></span><br><span class="line">  - option</span><br><span class="line"></span><br><span class="line">    - 0 与 wait 相同，阻塞 </span><br><span class="line"></span><br><span class="line">    - WNOHANG 如果当前没有子进程退出的，会立刻返回 </span><br><span class="line"></span><br><span class="line">  - 返回值 </span><br><span class="line"></span><br><span class="line">    - 如果设置了 WHOHANG，那么如果没有子进程退出，返回 0</span><br><span class="line">      - 如果有子进程退出，返回退出的 pid</span><br><span class="line">    - 失败返回 -1 （没有子进程）</span><br><span class="line"></span><br><span class="line">- 回收多个子进程 </span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    	pid_t wpid &#x3D; waitpid(-1,NULL,WNOHANG);</span><br><span class="line">    	if(wpid &#x3D;&#x3D; -1)</span><br><span class="line">    		break;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信</title>
    <url>/2021/06/09/Linux(2)-1%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="进程间通信"> 进程间通信 </h1>
<h2 id="ipc 概念">IPC 概念 </h2>
<ul>
<li>interProcess Communication 进程间通信 ，通过内核提供的缓冲区进行数据交换的机制 </li>
<li> 通信方式：
<ul>
<li>pipe 管道 </li>
<li>fifo 有名管道 </li>
<li>mmap 文件映射共享 IO-- 速度最快 </li>
<li> 本地 socket -- 最稳定 </li>
<li> 信号 携带信息量最小 </li>
<li> 共享内存 </li>
<li> 消息队列 </li>
</ul></li>
</ul>
<h2 id="pipe- 管道">pipe 管道 </h2>
<ul>
<li><p> 半双工通信 --- 同一个时刻只能一方发送 </p></li>
<li><p> 管道函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>pipefd 读写文件描述符 ， 0 - 读 1- 写 </li>
<li> 返回值 失败返回 -1，成功返回 0.</li>
</ul></li>
<li><p> 例子 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fd[<span class="number">1</span>],<span class="string">&quot;hello&quot;</span> ,<span class="number">5</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">12</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ret = read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            write(STDOUT_FILENO,buf,ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p> 父子进程实现 ps-grep</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关闭读端 </span></span><br><span class="line">        close（fd[<span class="number">0</span>]）;</span><br><span class="line">        <span class="comment">// 重定向 </span></span><br><span class="line">        dup2(fd[<span class="number">1</span>],STDOUT_FILENO);<span class="comment">// 标准输出重定向到管道写端 </span></span><br><span class="line">        <span class="comment">//excelp</span></span><br><span class="line">        excelp(<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;aux&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关闭写端 </span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 重定向, 标准输入重定向到管道读端 </span></span><br><span class="line">        dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">        <span class="comment">//excelp</span></span><br><span class="line">        exclp(<span class="string">&quot;grep&quot;</span>,<span class="string">&quot;grep&quot;</span>,<span class="string">&quot;bash&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li> 不关闭读端或写端时，会认为还存在数据要发送或写入，造成阻塞。</li>
</ul></li>
<li><p> 读管道 </p>
<ul>
<li> 写端全部关闭 -- read 读到 0，相当于读到文件末尾 </li>
<li> 写端没有全部关闭
<ul>
<li> 有数据 -- read 读到数据 </li>
<li> 没有数据 -- read 阻塞 fcntl 函数可以更改非阻塞 </li>
</ul></li>
</ul></li>
<li><p> 写管道 </p>
<ul>
<li> 读端全部关闭 -- 产生一个信号 SIGPIPE ，程序异常终止 </li>
<li> 读端未全部关闭
<ul>
<li> 管道已满 -- write 阻塞 </li>
<li> 管道未满 -- write 正常写入 </li>
</ul></li>
</ul></li>
<li><p> 计算管道大小 -- 512*8</p>
<ul>
<li><p>```c long fpathconf(int fd, int name); <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - ulimit -a</span><br><span class="line"></span><br><span class="line">- 管道的优缺点 </span><br><span class="line"></span><br><span class="line">  - 优点 </span><br><span class="line">    - 简单 </span><br><span class="line">  - 缺点 </span><br><span class="line">    - 只能有血缘关系的进程通信 </span><br><span class="line">    - 父子进程单方向通信，如果需要双向通信，需要创建多根管道 </span><br><span class="line"></span><br><span class="line">## FIFO</span><br><span class="line"></span><br><span class="line">​		命名管道，实现无血缘关系进程通信。</span><br><span class="line"></span><br><span class="line">- 创建一个管道的伪文件 </span><br><span class="line"></span><br><span class="line">  - mkfifo myfifo 命令创建 </span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;c</span><br><span class="line">    int mkfifo(const char* pathname,mode_t mode);</span><br></pre></td></tr></table></figure></p></li>
<li><p> 内核会针对 fifo 文件开辟一个缓冲区从，操作 fifo 文件，可以操作缓冲区，实现进程间通信 -- 文件读写 </p></li>
</ul></li>
<li><p> 打开 fifo 文件的时候吗，read 端会阻塞等待 write 端 open，write 端同理，也会阻塞等待另一端打开 </p></li>
</ul>
<h2 id="mmap--- 共享映射区">mmap-- 共享映射区 </h2>
<ul>
<li><p> 创建映射区 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot ,<span class="keyword">int</span> flags ,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>addr -- 传 NULL</li>
<li>length -- 映射区的长度 </li>
<li>port
<ul>
<li>PROT_READ 可读 </li>
<li>PROT_WRITE 可写 </li>
</ul></li>
<li>flags
<ul>
<li>MAP_SHARED 共享的，对内存的修改会影响源文件 </li>
<li>MAP_PRIVATE 私有的 </li>
</ul></li>
<li>fd 文件描述符 ，open 打开一个文件 </li>
<li>offset 偏移量 </li>
<li> 返回值
<ul>
<li> 成功 返回 可用内存首地址 </li>
<li> 失败 MAP_FAILED</li>
</ul></li>
</ul></li>
<li><p> 释放映射区 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> leength)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>addr 传 mmap 的返回值 </li>
<li>length mmap 创建的长度 </li>
<li> 返回值
<ul>
<li> 成功返回 0</li>
<li> 失败返回 -1</li>
</ul></li>
</ul></li>
<li><p> 注意事项 </p>
<ul>
<li> 不能改变 mem 变量的地址 </li>
<li> 文件的大小对映射区操作有影响，尽量避免对 mem 越界操作 </li>
<li>offset 必须是 4k 的整数倍 </li>
<li> 如果文件描述符先关闭，对 mmap 映射没有影响 </li>
<li>open 的时候可以创建一个文件来创建映射区，但大小不能为 0</li>
<li>open 文件不可以选择只选择 O_WRONLY，否则没有权限 </li>
<li> 当选择 MAP_SHARED 的时候，open 文件选择 O_RDONLY,prot 不可以选择 PROT_READ|PROT_WRITE, 因为没有权限对文件进行修改。SHARED 的时候要 &lt;= open 文件的权限 </li>
</ul></li>
<li><p> 实现父子进程间的通信 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建映射区 </span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;mem.txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> *mem = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED ,fd , <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mem == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *mem = <span class="number">100</span> ;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        *mem = <span class="number">1001</span> ;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap(mem,<span class="number">4</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 匿名映射 </p>
<p> 可以创建一个临时的映射区域, 不用创建一个文件。</p>
<ul>
<li>MAP_ANON MAP_ANONMOUS 这两个宏在有些 unix 系统没有
<ul>
<li> 可以在 /dev/zero ，可以随意映射 </li>
<li>/dev/null ，一般错误信息重定向到这个文件中 </li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建映射区 </span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;mem.txt&quot;</span>,O_RDWR);<span class="comment">//mem.txt 创建的一个用来做映射的文件 </span></span><br><span class="line">    <span class="keyword">int</span> *mem = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANON ,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mem == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *mem = <span class="number">100</span> ;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        *mem = <span class="number">1001</span> ;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap(mem,<span class="number">4</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 无血缘关系进程通信 </p>
<ul>
<li> 写 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> sid;</span><br><span class="line">	<span class="keyword">char</span> sname[<span class="number">20</span>];</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span> *argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(Student);</span><br><span class="line">	ftruuncate(fd,length);</span><br><span class="line">	</span><br><span class="line">	Student *stu = mmap(<span class="literal">NULL</span> , length ,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(stu== MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		stu-&gt;sid = num ;</span><br><span class="line">        <span class="built_in">sprintf</span>(stu-&gt;sname,<span class="string">&quot;xiaoming-%03d&quot;</span>,num++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mummap(stu,length);</span><br><span class="line">    close(fd);</span><br><span class="line">	</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li> 读 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> sid;</span><br><span class="line">	<span class="keyword">char</span> sname[<span class="number">20</span>];</span><br><span class="line">&#125;Student;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span> *argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>],O_RDWD);</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(Student);</span><br><span class="line">    Student *stu = mmap(<span class="literal">NULL</span> , length ,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(stu== MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sid = %d, sname = %s\n&quot;</span>,stu-&gt;sid,stu-&gt;sname);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap(stu,length);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li> 如果进程要通信，flags 必须设为 MAP_SHARED, 数据修改不能改变映射区的内容 </li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>信号</title>
    <url>/2021/06/09/Linux(3)-1%E3%80%81%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="信号"> 信号 </h1>
<h2 id="信号的基本概念"> 信号的基本概念 </h2>
<ul>
<li><p> 概念 </p>
<ul>
<li> 简单，不能带大量信息，满足特定条件发生 </li>
<li> 内核产生信号，内核处理 </li>
<li> 产生
<ul>
<li> 按键 </li>
<li> 调用函数 </li>
<li> 定时器 </li>
<li> 命令 -- 系统 api 产生信号 kill 函数 </li>
<li> 硬件异常 </li>
</ul></li>
<li> 状态
<ul>
<li> 产生 </li>
<li> 递达 信号到达并且处理完 </li>
<li> 未决 信号被阻塞 </li>
</ul></li>
<li> 默认处理方式
<ul>
<li> 忽略 </li>
<li> 执行默认动作 </li>
<li> 捕获 </li>
</ul></li>
<li>4 要素
<ul>
<li> 编号 </li>
<li> 事件 </li>
<li> 名称 </li>
<li> 默认处理动作
<ul>
<li> 忽略 </li>
<li> 终止 </li>
<li> 终止 +core</li>
<li> 暂停 </li>
<li> 继续 </li>
</ul></li>
</ul></li>
<li> 软件产生的中断，会有延迟 </li>
<li>19 号信号不能捕捉，暂停，不能阻塞 </li>
<li>0 号信号有特殊的含义 </li>
</ul></li>
<li><p> 阻塞信号集 </p>
<p> 将某些信号加入集合，对他们设置屏蔽，当屏蔽 x 信号后，再收到该信号，该信号的处理将推后 (解除屏蔽后)</p></li>
<li><p> 未决信号集 </p>
<ul>
<li> 信号产生，未决信号集中描述该信号的位立刻翻转为 1， 表信号处于未决状态。当信号被处理对应位翻转回 0。这一时刻往往非常短暂。</li>
<li> 信号产生后由于某些原因 (主要是阻塞)，不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li>
</ul></li>
<li><p>kill(pid,sig) 用于发送信号。</p></li>
</ul>
<h2 id="信号的产生"> 信号的产生 </h2>
<ul>
<li><p> 系统 api 产生信号 </p>
<ul>
<li>kill 函数 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid , <span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">//pid &gt; 0 , 要发送进程 ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pid = 0，代表当前调用进程组内所有进程 </span></span><br><span class="line"><span class="comment">// pid = -1，代表有权限发送的所有进程 </span></span><br><span class="line"><span class="comment">// pid &lt; 0 ,  代表 -pid 对应的组内所有进程 </span></span><br><span class="line"><span class="comment">// sig 对应的信号 </span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>raise 函数 --- 给自己发信号 </p></li>
<li><p>abort 函数 -- 给自己发送异常信号 </p></li>
<li><p> 时钟信号 -- alarm 函数 </p>
<ul>
<li><p> 一次性 </p></li>
<li><p>```c unsigned int alarm(unsigned int seconds); <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 定时给自己发送 SIGALRM 信号.</span><br><span class="line">  - 返回值，上次定时剩余的描述 </span><br><span class="line">  - 如果参数为 0，取消定时 </span><br><span class="line"></span><br><span class="line">- setitimer 函数 </span><br><span class="line"></span><br><span class="line">  - 周期性发送信号 </span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;c</span><br><span class="line">    int setitimer(int which ,const struct itimerval *new_value , struct itimerval *old_value);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>which
<ul>
<li>ITIMER_REAL 自然定时法 SIGALLRM</li>
<li>ITIMER_VIRTUAL 计算进程执行时间 SIGVTALRM</li>
<li>ITIMER_PROT 进程执行时间 + 调度时间 ITIMER_VIRTUAL</li>
</ul></li>
<li>new_value 要设置的定时时间 </li>
<li>old_value 原定时时间 </li>
<li> 返回值 0 成功 -1 失败 </li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="信号集的操作"> 信号集的操作 </h2>
<ul>
<li><p> 操作函数 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">// 清空信号集 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">// 填充信号集 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">// 从集合中添加某个信号 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">// 从集合中删去某个信号 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">// 是否为集合里的成员 </span></span><br></pre></td></tr></table></figure></li>
<li><p> 设置阻塞或解除阻塞信号集 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span> ,<span class="keyword">sigset_t</span> *oldset)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>how</p>
<ul>
<li><p>SIG_BLOCK 设置阻塞 </p></li>
<li><p>SIG_UNBLOCK 解除阻塞 </p></li>
<li><p>SIG_SETMASK 设置 set 为新的阻塞信号集 </p></li>
</ul></li>
<li><p>set 传入的信号集 </p></li>
<li><p>oldset 旧的信号集，传出 </p></li>
</ul></li>
<li><p> 获取未决信号集 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>set 传出参数，当前的未决信号集 </li>
</ul></li>
</ul>
<h2 id="信号捕捉"> 信号捕捉 </h2>
<ul>
<li><p> 防止进程意外死亡 </p></li>
<li><p> 捕捉函数 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">singhandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>signum 要捕捉的信号 </li>
<li>handler 要执行的捕捉函数指针，函数应该声明 void func(int);</li>
</ul></li>
<li><p> 注册捕捉函数 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">const</span> struct sigaction *act ,struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>signum 要捕捉的信号 </li>
<li>act 传入的动作 </li>
<li>oldact 原动作 恢复现场 </li>
</ul></li>
<li><p> 例子 -- sigaction 捕捉 setitimer 产生信号 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sig</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch %d sig\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srtuct sigaction act;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = catch_sig;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGALRM,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">myit</span> =</span> &#123;&#123;<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    setitimer(ITIMER_REAL,&amp;myit,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 特性 </p>
<ul>
<li> 捕捉什么信号，捕捉期间自动屏蔽该信号 </li>
<li> 阻塞的常规信号不支持排队，产生多次只记录一次（后 32 个信号支持排队）</li>
<li> 进程正常运行时，默认 PCB 中有一个信号屏蔽字，它决定了进程自动屏蔽哪些信号。捕捉到了某个信号后, 执行期间的要屏蔽的信号不是由信号屏蔽字决定，而是用 sa_mask 来指定，信号处理函数调用完后再恢复.</li>
</ul></li>
</ul>
<h2 id="sigchld 信号">SIGCHLD 信号 </h2>
<ul>
<li><p> 子进程暂停或者退出的时候会发送 SIGCHILD 信号，我们可以通过捕捉 SIGCHILD 信号来回收子进程 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sig</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid ;</span><br><span class="line">    <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span> , <span class="literal">NULL</span> , WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait child %d ok \n&quot;</span>,wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> ;</span></span><br><span class="line">        act.as_flags = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.ac_handler = catch_sig;</span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 注意事项 -- 当注册捕捉晚于子进程死亡时 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_sig</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid ;</span><br><span class="line">    <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span> , <span class="literal">NULL</span> , WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait child %d ok \n&quot;</span>,wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在创建子进程前屏蔽 SIGCHLD 信号 </span></span><br><span class="line">    <span class="keyword">sigset_t</span> myset,oldset;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    sigaddset(&amp;myset,SIGCHLD);</span><br><span class="line">    <span class="comment">//oldset 保留现场  设置了 SIGCHLD 到阻塞信号集 </span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;oldset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	sleep(<span class="number">2</span>);<span class="comment">// 模拟注册捕捉晚于子进程死亡时 </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> ;</span></span><br><span class="line">        act.as_flags = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.ac_handler = catch_sig;</span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 解除屏蔽现场 </span></span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;oldset ,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>守护进程</title>
    <url>/2021/06/12/Linux(4)-1%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>​</p>
<span id="more"></span>
<h1 id="守护进程">守护进程</h1>
<h2 id="进场组">进场组</h2>
<ul>
<li>代表一个或多个进程的基合。</li>
</ul>
<h2 id="会话 --- 多个进程组对应一个会话">会话 -- 多个进程组对应一个会话</h2>
<ul>
<li><p>调用进程不能是进程组组长，该进程变成新会话首进程</p></li>
<li><p>该进程成为一个新进程组的组长进程</p></li>
<li><p>新会话丢弃原有的控制终端，该会话没有控制终端</p></li>
<li><p>该调用进程是组长进程，则出错返回</p></li>
<li><p>建立新会话时，先调用 fork，父进程终止，子进程调用 setsid</p></li>
</ul>
<h2 id="setsid 函数">setsid 函数</h2>
<ul>
<li><p>获取进程所属的会话 ID</p></li>
<li><p>```c pid_t getsid(pid_t pid); <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  - 成功：返回调用进程的会话 ID，失败：-1，设置 errno</span><br><span class="line">  </span><br><span class="line">  - pid 为 0 表示察看当前基层 session ID</span><br><span class="line"></span><br><span class="line">## 守护进程 </span><br><span class="line"></span><br><span class="line">- 调用 setsid 函数创建一个新的 Session，并成为 Session Leader</span><br><span class="line"></span><br><span class="line">- 创建守护进程模型</span><br><span class="line">  </span><br><span class="line">  - 创建子进程，父进程退出</span><br><span class="line">    </span><br><span class="line">    - 所有工作在子进程中进行形式上脱离了控制终端</span><br><span class="line">  </span><br><span class="line">  - 在子进程中创建新会话</span><br><span class="line">    </span><br><span class="line">    - setsid() 函数 </span><br><span class="line">    </span><br><span class="line">    - 使子进程完全独立出来，脱离控制</span><br><span class="line">  </span><br><span class="line">  - 改变当前目录为根目录  -- 非必须</span><br><span class="line">    </span><br><span class="line">    - chdir() 函数 </span><br><span class="line">    </span><br><span class="line">    - 防止占用可卸载的文件系统</span><br><span class="line">    </span><br><span class="line">    - 也可以换成其他路径</span><br><span class="line">  </span><br><span class="line">  - 重设文件权限掩码</span><br><span class="line">    </span><br><span class="line">    - umask() 函数</span><br><span class="line">    </span><br><span class="line">    - 防止继承的文件创建屏蔽子拒绝某些权限</span><br><span class="line">    </span><br><span class="line">    - 增加守护进程灵活性</span><br><span class="line">  </span><br><span class="line">  - 关闭文件描述符</span><br><span class="line">    </span><br><span class="line">    - 继承的打开文件不会用到，浪费系统资源，无法卸载</span><br><span class="line">  </span><br><span class="line">  - 开始执行守护进程核心工作</span><br><span class="line">  </span><br><span class="line">  - 守护进程退出处理程序模型</span><br><span class="line"></span><br><span class="line">- 创建守护进程</span><br><span class="line">  </span><br><span class="line">  - &#96;&#96;&#96;c</span><br><span class="line">    #include&lt;stdio.h&gt;</span><br><span class="line">    #include&lt;unistd.h&gt;</span><br><span class="line">    #include&lt;sys&#x2F;types.h&gt;</span><br><span class="line">    #include&lt;sys&#x2F;stat.h&gt;</span><br><span class="line">    #include&lt;fcntl.h&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;stdlib.h&gt;</span><br><span class="line">    #include&lt;signal.h&gt;</span><br><span class="line">    #include&lt;sys&#x2F;time.h&gt;</span><br><span class="line">    #include&lt;time.h&gt;</span><br><span class="line">    #define _FILE_NAME_FORMAT_  &quot;%s&#x2F;log&#x2F;mydaemon.%ld&quot;  &#x2F;&#x2F; 定义文件格式化</span><br><span class="line">    </span><br><span class="line">    void touchfile(int num)</span><br><span class="line">    </span><br><span class="line">        char *HomeDir &#x3D; getenv(&quot;HOME&quot;);</span><br><span class="line">        char strFilename[256] &#x3D; &#123;0&#125;;</span><br><span class="line">        sprintf(strFilename,_FILE_NAME_FORMAT_ ,HomeDir,time(NULL));</span><br><span class="line">        int fd &#x3D; open(strFilename,O_RDWR|O_CREAT , 0666);</span><br><span class="line">        if(fd &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;open error&quot;);</span><br><span class="line">            exit(1);    </span><br><span class="line">        &#125;</span><br><span class="line">        close(fd;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建子进程，父进程退出</span><br><span class="line">        pid_t pid &#x3D; fork();</span><br><span class="line">        if(pid &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当会长</span><br><span class="line">        setsid();</span><br><span class="line">        &#x2F;&#x2F; 设置掩码</span><br><span class="line">        umask(0);</span><br><span class="line">        &#x2F;&#x2F; 切换目录</span><br><span class="line">        chdir(getenv(&quot;HOME&quot;));</span><br><span class="line">        &#x2F;&#x2F; 关闭文件描述符</span><br><span class="line">        &#x2F;&#x2F;close(1),close(2),close(3)</span><br><span class="line">        &#x2F;&#x2F; 执行核心逻辑</span><br><span class="line">        struct itimerval myit &#x3D; &#123;&#123;60,0&#125;,&#123;1,0&#125;&#125;;</span><br><span class="line">        setitmer(ITIMER_REAL,&amp;myit,NULL);</span><br><span class="line">        struct sigaction act;</span><br><span class="line">        act.sa_flags &#x3D; 0;</span><br><span class="line">        sigemtyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_handler &#x3D; touchfile;</span><br><span class="line">        sigaction(SIGALRM,&amp;act,NULL);</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 退出</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></p></li>
<li><p>扩展</p>
<ul>
<li><p>通过 nohup 指令也可以达到守护进程创建的效果</p></li>
<li><p>nohup cmd [&gt; 1.log]&amp;</p>
<ul>
<li><p>nohup 指令会让 cmd 收不到 SIGHUP 信号</p></li>
<li><p>&amp; 代表后台运行</p></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2021/06/12/Linux(5)-1%E3%80%81%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>​</p>
<span id="more"></span>
<h1 id="线程">线程</h1>
<h2 id="线程相关概念">线程相关概念</h2>
<ul>
<li><p>线程 man page 安装</p>
<ul>
<li><p>```c sudo apt-get installmanpages-posix-dev <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 概念：</span><br><span class="line">  </span><br><span class="line">  - 轻量级的进程，一个进程内部可以有多个线程，默认情况下一个进程只有一个线程 </span><br><span class="line">  </span><br><span class="line">  - 线程时最小的执行单位，进程时最小的系统资源分配单位</span><br><span class="line">  </span><br><span class="line">  - 内核实现都是通过 clone 函数实现的</span><br><span class="line">  </span><br><span class="line">  - 线程也有自己的 PCB</span><br><span class="line">  </span><br><span class="line">  - 使用 ps -Lf pid  查看指定线程的 lwp 号</span><br><span class="line">  </span><br><span class="line">  - malloc 和 mmap 申请的内存可以被其他线程释放</span><br><span class="line">  </span><br><span class="line">  - 可以创建(cpu 核数 *2 + 2) 个线程</span><br><span class="line"></span><br><span class="line">## 线程共享资源</span><br><span class="line"></span><br><span class="line">- 文件描述符表</span><br><span class="line"></span><br><span class="line">- 每种信号的处理方式</span><br><span class="line"></span><br><span class="line">- 当前工作目录</span><br><span class="line"></span><br><span class="line">- 用户 ID 和组</span><br><span class="line"></span><br><span class="line">- 内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F; 共享库)</span><br><span class="line"></span><br><span class="line">## 线程非共享资源</span><br><span class="line"></span><br><span class="line">- 线程 id</span><br><span class="line"></span><br><span class="line">- 处理器线场和栈指针(内核栈)</span><br><span class="line"></span><br><span class="line">- 独立的栈空间(用户空间栈)</span><br><span class="line"></span><br><span class="line">- errno 变量</span><br><span class="line"></span><br><span class="line">- 信号屏蔽字</span><br><span class="line"></span><br><span class="line">- 调度优先级</span><br><span class="line"></span><br><span class="line">## 线程优缺点 -- 优点突出</span><br><span class="line"></span><br><span class="line">- 优点：</span><br><span class="line">  </span><br><span class="line">  - 提高程序并发性</span><br><span class="line">  </span><br><span class="line">  - 开销小</span><br><span class="line">  </span><br><span class="line">  - 数据通信、共享数据方便(包括全局变量)</span><br><span class="line"></span><br><span class="line">- 缺点</span><br><span class="line">  </span><br><span class="line">  - 库函数，不稳定</span><br><span class="line">  </span><br><span class="line">  - 调试、编写困难</span><br><span class="line">  </span><br><span class="line">  - 对信号支持不好</span><br><span class="line"></span><br><span class="line">## 创建一个线程</span><br><span class="line"></span><br><span class="line">- 创建函数</span><br><span class="line">  </span><br><span class="line">  &#96;&#96;&#96;c</span><br><span class="line">  int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start_routine)(void *),void *arg);</span><br></pre></td></tr></table></figure></p></li>
<li><p>thread 线程 id，传出参数</p></li>
<li><p>attr 代表线程的属性</p></li>
<li><p>函数指针</p></li>
<li><p>arg 线程执行函数的参数</p></li>
<li><p>需要链接 -pthread 库</p></li>
</ul></li>
<li><p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;uinstd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num  %d&quot;</span>,num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am a thread %d\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    pthread_creat(&amp;tid,<span class="literal">NULL</span>,thr,(<span class="keyword">void</span> *)i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am a main thread %d\n&quot;</span>,pthread_self());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程退出">线程退出</h2>
<ul>
<li><p>```c pthread_exit(NULL); <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line">  </span><br><span class="line">  - 在线程可以使用 pthread_exit(NULL);</span><br><span class="line">  </span><br><span class="line">  - 在线程中使用 return</span><br><span class="line">  </span><br><span class="line">  - exit 代表退出整个进程</span><br><span class="line"></span><br><span class="line">## 线程回收 -- 阻塞等待回收</span><br><span class="line"></span><br><span class="line">- 函数</span><br><span class="line">  </span><br><span class="line">  &#96;&#96;&#96;c</span><br><span class="line">  int pthread_join(pthread_t thread,void **retval);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>thread 创建的时候传出的第一个参数</p></li>
<li><p>retval 线程的退出信息</p></li>
</ul></li>
</ul>
<h2 id="杀死线程">杀死线程</h2>
<ul>
<li><p>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>被该函数杀死后线程退出信息为 -1</p></li>
<li><p>强行设置取消点</p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_testcancel</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程分离">线程分离</h2>
<ul>
<li><p>线程若有该机制，将不会产生僵尸进程</p></li>
<li><p>线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放, 不需要用 pthread_join 函数</p></li>
<li><p>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程属性设置分离">线程属性设置分离</h2>
<ul>
<li><p>初始化线程属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>销毁线程属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>设置属性分离</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">int</span> detachstate)</span></span>;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>attr init 初始化的属性</p></li>
<li><p>detachstate</p>
<ul>
<li><p>PTHREAD_CREATE_DETACHED 线程分离</p></li>
<li><p>PTHREAD_CREATE_JOINABLE 允许回收</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="线程同步 -- 需要加锁">线程同步 -- 需要加锁</h2>
<ul>
<li><p>协调步骤，顺序执行</p></li>
<li><p>数据混乱原因</p>
<ul>
<li><p>资源共享</p></li>
<li><p>调度随机</p></li>
<li><p>线程间缺少必要的同步机制</p></li>
</ul></li>
</ul>
<h2 id="互斥量 ----mutex- 建议锁">互斥量 -- mutex、 建议锁</h2>
<ul>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>restrict 约束该块内存区域对应的数据，只能通过后面的变量进行访问和修改</p></li>
<li><p>mutex 互斥量 -- 锁</p></li>
<li><p>attr 互斥量的属性，可以不考虑，传 NULL</p></li>
<li><p>常量初始化，此时可以使用 init</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITALIZER;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>销毁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(pthread_mutex *mutex)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>mutex init 初始化的锁</li>
</ul></li>
<li><p>加锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>mutex init 初始化的锁</p></li>
<li><p>如果当前未锁，成功，加锁</p></li>
<li><p>如果已经加锁，阻塞等待</p></li>
</ul></li>
<li><p>解锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<ul>
<li><p>初始化</p></li>
<li><p>加锁</p></li>
<li><p>执行逻辑 -- 操作共享数据</p></li>
<li><p>解锁</p></li>
<li><p>注意：加锁需要最小粒度，不要一直占用临界区</p></li>
</ul></li>
<li><p>尝试加锁</p>
<ul>
<li>```c int pthread_mutex_trylock(pthread_mutex *mutex); <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 死锁</span><br><span class="line"></span><br><span class="line">- 原因</span><br><span class="line">  </span><br><span class="line">  - 加锁 2 次</span><br><span class="line">  </span><br><span class="line">  - 交叉锁</span><br><span class="line"></span><br><span class="line">- 解决办法</span><br><span class="line">  </span><br><span class="line">  - 每个线程申请锁的顺序要固定</span><br><span class="line">  </span><br><span class="line">  - 如果申请到一把锁，申请另一把的时候，申请失败，应该释放已经掌握的</span><br><span class="line"></span><br><span class="line">## 读写锁</span><br><span class="line"></span><br><span class="line">- 特点：读共享，写独占，写优先级高</span><br><span class="line"></span><br><span class="line">- 状态</span><br><span class="line">  </span><br><span class="line">  - 未加锁</span><br><span class="line">  </span><br><span class="line">  - 读锁</span><br><span class="line">  </span><br><span class="line">  - 写锁</span><br><span class="line"></span><br><span class="line">- 使用场景：适合读的线程多</span><br><span class="line"></span><br><span class="line">- 初始化</span><br><span class="line">  </span><br><span class="line">  &#96;&#96;&#96;c</span><br><span class="line">  int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,</span><br><span class="line">          const pthread_rwlockattr_t *restrict attr);</span><br><span class="line">  &#x2F;&#x2F; 或</span><br><span class="line">  pthread_rwlock_t rwlock &#x3D; PTHREAD_RWLOCK_INITALIZER;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>销毁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * rwlock)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>加读锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * rwlock)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>加写锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * rwlock)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>释放锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> * rwlock)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条件变量 ---pthread_cond">条件变量 ---pthread_cond</h2>
<p>    不是锁，可以引起阻塞，要和互斥量组合使用</p>
<ul>
<li><p>超时等待</p>
<ul>
<li>ty_sec 绝对时间，填写时 time(NULL) + 600 ===&gt; 设置超时 600s</li>
</ul></li>
<li><p>条件变量阻塞等待</p>
<ul>
<li><p>先释放锁 mutex</p></li>
<li><p>阻塞在 cond 条件变量上</p></li>
</ul></li>
<li><p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> beginnum = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ProdInfo</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ProdInfo</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">ProdInfo *Head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_producter</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 负责在链表添加数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ProdInfo *prod = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ProdInfo));</span><br><span class="line">        prod-&gt;num = beginnum++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----%s------self=%lu-----%d\n&quot;</span>,_FUNCTION_,pthread_self(),prod-&gt;num);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        prod-&gt;next = Head;</span><br><span class="line">        Head = prod;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 发起通知</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        sleep(rand()%<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_customer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ProdInfo *prod = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 取链表的数据</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(Head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);<span class="comment">// 在此之前必须先加锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        prod = Head;</span><br><span class="line">        Head = Head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----%s------self=%lu-----%d\n&quot;</span>,_FUNCTION_,pthread_self(),prod-&gt;num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(round%<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">free</span>(prod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">2</span>];</span><br><span class="line">    pthread_create(&amp;tid[<span class="number">0</span>],<span class="literal">NULL</span>,thr_producter,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid[<span class="number">1</span>],<span class="literal">NULL</span>,thr_customer,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="信号量 --sem- 加强版互斥量">信号量 --sem 加强版互斥量</h2>
<p>        信号的量的初值，决定了占用信号量的线程的个数.</p>
<ul>
<li><p>允许多个线程访问共享资源</p></li>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem,<span class="keyword">int</span> pshared,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sem 定义的信号量，传出</p></li>
<li><p>pshared</p>
<ul>
<li><p>0 代表线程信号量</p></li>
<li><p>非 0 代表进程信号量</p></li>
</ul></li>
<li><p>value 定义信号量的个数</p></li>
</ul></li>
<li><p>销毁</p></li>
<li><p>申请信号量 ，申请成功 value--</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>当信号量为 0 时，阻塞</li>
</ul></li>
<li><p>释放信号量 value++</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件锁">文件锁</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lk</span>;</span></span><br><span class="line">lk.l_type = F_WRLCK;</span><br><span class="line">lk._whence = SEEK_SET;</span><br><span class="line">lk.start = <span class="number">0</span>;</span><br><span class="line">lk.l_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(fcntl(fd,F_SETLK,&amp;lk) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;get lock err&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-hexo</title>
    <url>/2020/11/18/hello-hexo/</url>
    <content><![CDATA[<p> 这是用 hexo 搭建 Blog 后第一个文章记录一下。之后将在这里更新一些平时学习的东西，供自己复习。<br>
<span id="more"></span></p>
<h2 id="现在的坑"> 现在的坑：</h2>
<p>### 1、UE4</p>
<ol type="1">
<li><del> 新手入门 -- 张嘉诚 </del><br>
</li>
<li><del> 制作小游戏 -TD https://github.com/CHFKA/TD.git 跟着做的视频 https://www.bilibili.com/video/BV15z411B7sb</del></li>
</ol>
<h3 id="c">2、C</h3>
<ol type="1">
<li><del>linux 学习 -- 黑马视频 </del></li>
<li><del>web 服务器 -socket select poll epoll libevent</del></li>
<li>CJson 项目 </li>
</ol>
<h3 id="c-1">3、C++</h3>
<ol type="1">
<li><del>01 - 侯捷 - C++ 面向对象高级开发（上下两部曲）</del></li>
<li><del>02 - 侯捷 - STL 标准库和泛型编程 </del></li>
</ol>
<h3 id="数据结构与算法">4、数据结构与算法 </h3>
<ol type="1">
<li>ACWing 视频学习 -- 进度：数据结构（三）</li>
</ol>
<h3 id="计算机网络">5、计算机网络 </h3>
<ol type="1">
<li> 中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第 7 版，James F.Kurose，Keith W.Ross）》课程 </li>
</ol>
]]></content>
      <tags>
        <tag>简介</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 windows（一）</title>
    <url>/2020/11/23/%E5%AD%A6%E4%B9%A0windows%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>​ 这篇是记录了自己学习 windows 程序设计所碰到问题记录的 Blog</p>
<span id="more"></span>
<h2 id="句柄 handle 是什么"> 句柄（handle）是什么 </h2>
<p>​ 通常需要用某种方式能让你访问一个资源，而这个资源通常存放在一个表结构中，但操作系统不会给你对应项的地址让你去访问其中一项，而是给你这个项在表中的下标，这样你只要知道这个下标就能指明要访问的项了，这个表（其实就是个数组）就像整齐排列的一些抽屉，你要用抽屉的时候必须得通过抽屉的把手来打开它，这个表呢就像这些抽屉一样，而这个句柄就被比喻为抽屉的把手（柄）</p>
<h2 id="undefined-reference-to__imp_getstockobject 的处理">undefined reference to`__imp_GetStockObject' 的处理 </h2>
<p>​ 编程环境是 windows+vs code。</p>
<p>​ 在 tasks.json 中的 args 下加入“-lwinmm”. 同理当继续碰到 undefined reference to 这类问题可以在 tasks.json 文件中链接相对应库 </p>
]]></content>
      <tags>
        <tag>windons</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 mongodb 及 c、c++ 驱动安装</title>
    <url>/2021/07/04/%E5%AE%89%E8%A3%85mongodb%E5%8F%8Ac%E3%80%81c++%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​ 这是在 linux 环境下安装 mongodb 及其 c/c++ 驱动的步骤。</p>
<span id="more"></span>
<h1 id="安装 mongodb"> 安装 mongodb</h1>
<p>​ 使用是 ubuntu 20.4 版本，更新源后可以直接 sudo apt-get 安装 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mongodb</span><br></pre></td></tr></table></figure>
<h1 id="安装 cc 驱动"> 安装 c/c++ 驱动 </h1>
<p>​ 安装驱动比较麻烦，要依赖的库比较多 </p>
<h2 id="cmake- 安装">cmake 安装 </h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure>
<h2 id="依赖库安装及驱动安装"> 依赖库安装及驱动安装 </h2>
<p> 参照 https://blog.51cto.com/juestnow/1950039</p>
<h1 id="年 7 月 10 日更新 -- 官方教程">2021 年 7 月 10 日更新 -- 官方教程 </h1>
<p> 推荐从下面链接下载 </p>
<p>https://github.com/mongodb/mongo-cxx-driver/releases</p>
<p> 安装教程 </p>
<p>http://mongocxx.org/mongocxx-v3/installation/linux/</p>
<p> 按照教程里的步骤进行先安装 c 驱动 再安装 c++ 驱动 </p>
]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>快排</title>
    <url>/2021/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(1)--%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="快速排序"> 快速排序 </h1>
<ul>
<li> 分治
<ul>
<li> 确定分界点： 左右分界，中间值 、随机值 x</li>
<li><strong> 划分区间： 使得左区间的数都小于等于 x，右区间的数都大于等于 x</strong></li>
<li> 递归处理左右两区间 </li>
</ul></li>
</ul>
<h2 id="划分区间方法一"> 划分区间方法（一）</h2>
<ul>
<li> 数组 a，b</li>
<li> 遍历数组，小等于 x，放入 a，大于 x，放入 b</li>
<li> 先把 a 中的数放入区间，再把 b 中的数放入区间 </li>
</ul>
<h2 id="划分区间方法二"> 划分区间方法（二）</h2>
<ul>
<li> 在左右边界设置双指针 </li>
<li> 两边向 x 移动并判断，左边出现大于 x 暂停，右边出现小等于 x 暂停。</li>
<li> 两指针交换数据。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="comment">// 快排模板 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = q[(l + r)/<span class="number">2</span>], i =l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++ ; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j-- ; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表与邻接表</title>
    <url>/2021/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(10)--%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>使用数组 (静态链表) 来模拟单链表和双链表，使用 new(动态链表)会超时。</p>
<ul>
<li>单链表 -----&gt; 邻接表：存储图和树</li>
<li>双链表 -----&gt; 优化某些问题</li>
</ul>
<span id="more"></span>
<h2 id="链表与邻接表">链表与邻接表</h2>
<h3 id="单链表">单链表</h3>
<hr>
<p>实现一个单链表，链表初始为空，支持三种操作：</p>
<ol type="1">
<li>向链表头插入一个数；</li>
<li>删除第 k 个插入的数后面的数；</li>
<li>在第 k 个插入的数后插入一个数。</li>
</ol>
<p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p><strong>注意</strong>: 题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>
<hr>
<p><span class="math inline">\(head(头节点)-&gt;O(指针，值)-&gt;\phi(空指针)\)</span></p>
<p>现用 head 代表头节点的下标，e[N]代表值，ne[N]代表节点 i 的 next 指针，idx 代表使用了多少的节点</p>
<p>实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> head,e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 x 插到头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 x 插到 k 下标的后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将下标是 k 的点删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k,x;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span>(!k)</span><br><span class="line">            &#123;</span><br><span class="line">                head = ne[head];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双链表">双链表</h3>
<hr>
<p>实现一个双链表，双链表初始为空，支持 55 种操作：</p>
<ol type="1">
<li>在最左侧插入一个数；</li>
<li>在最右侧插入一个数；</li>
<li>将第 k 个插入的数删除；</li>
<li>在第 k 个插入的数左侧插入一个数；</li>
<li>在第 k 个插入的数右侧插入一个数</li>
</ol>
<p>现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。</p>
<p><strong>注意</strong>: 题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>
<hr>
<p>现用 e[N]代表值，l[N]代表节点 i 的左边指针，r[N]代表节点 i 的右边指针，idx 代表使用了多少的节点</p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k,x;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[k+<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k+<span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与队列</title>
    <url>/2021/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(11)--%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>用数组模拟栈与队列的操作；</p>
<span id="more"></span>
<h1 id="栈">栈</h1>
<p>实现一个栈，栈初始为空，支持四种操作：</p>
<ol type="1">
<li><code>push x</code> – 向栈顶插入一个数 x；</li>
<li><code>pop</code> – 从栈顶弹出一个数；</li>
<li><code>empty</code> – 判断栈是否为空；</li>
<li><code>query</code> – 查询栈顶元素。</li>
</ol>
<p>现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。</p>
<hr>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> stk[N] , tt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stk[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tt-- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tt &gt; <span class="number">0</span>) <span class="keyword">return</span> flase;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stk[tt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈">单调栈</h2>
<p>给定一个长度为 NN 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> stk[N] , tt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= x) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt) cout &lt;&lt; stk[tt] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        stk[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="队列">队列</h1>
<p>实现一个队列，队列初始为空，支持四种操作：</p>
<ol type="1">
<li><code>push x</code> – 向队尾插入一个数 xx；</li>
<li><code>pop</code> – 从队头弹出一个数；</li>
<li><code>empty</code> – 判断队列是否为空；</li>
<li><code>query</code> – 查询队头元素。</li>
</ol>
<p>现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。</p>
<hr>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stk[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hh++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hh &gt; tt) <span class="keyword">return</span> flase;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[hh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列 -- 滑动窗口">单调队列 -- 滑动窗口</h2>
<p>给定一个大小为 n≤1000000 的数组。</p>
<p>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。</p>
<p>你只能在窗口中看到 k 个数字。</p>
<p>每次滑动窗口向右移动一个位置。</p>
<p>以下是一个例子：</p>
<p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，k 为 3。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">窗口位置</th>
<th style="text-align: center;">最小值</th>
<th style="text-align: center;">最大值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">[1 3 -1] -3 5 3 6 7</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">1 [3 -1 -3] 5 3 6 7</td>
<td style="text-align: center;">-3</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1 3 [-1 -3 5] 3 6 7</td>
<td style="text-align: center;">-3</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: center;">1 3 -1 [-3 5 3] 6 7</td>
<td style="text-align: center;">-3</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1 3 -1 -3 [5 3 6] 7</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: center;">1 3 -1 -3 5 [3 6 7]</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">7</td>
</tr>
</tbody>
</table>
<p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<hr>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> a[N], q[N]; <span class="comment">// q[n]存的是下标 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="comment">// 当队列不为空(hh &lt;= tt) 且 当当前滑动窗口的大小(i - q[hh] + 1)&gt; 我们设定的滑动窗口的大小(k)</span></span><br><span class="line">        <span class="comment">// 队列弹出队列头元素以维持滑动窗口的大小</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - q[hh] + <span class="number">1</span> &gt; k) hh++;</span><br><span class="line">        <span class="comment">// 构造单调递增队列</span></span><br><span class="line">        <span class="comment">// 当队列不为空(hh &lt;= tt) 且 当队列队尾元素 &gt;= 当前元素(a[i]) 时,</span></span><br><span class="line">        <span class="comment">// 那么队尾元素就一定不是当前窗口最小值, 删去队尾元素, 加入当前元素(q[ ++ tt] = i)</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[q[hh]]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - q[hh] + <span class="number">1</span> &gt; k) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2021/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(12)--KMP/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>KMP 算法是一种改进的字符串匹配算法。KMP 算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。</p>
<span id="more"></span>
<h1 id="字符串匹配算法">字符串匹配算法</h1>
<p>给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p>
<p>模板串 P 在模式串 S 中多次作为子串出现。</p>
<p>求出模板串 P 在模式串 S 中所有出现的位置的起始下标。</p>
<hr>
<ul>
<li>暴力算法：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> S[N],P[M];<span class="comment">//S[n]是长字符串  P[N]是短字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] != P[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>KMP 算法： KMP 主要分两步：求 next 数组、匹配字符串</li>
</ul>
<p>next[]是“部分匹配值表”，即 next 数组，它存储的是每一个下标对应的“部分匹配值”。对 next[ j] ，是 p[1, j]串中前缀和后缀相同的最大长度（部分匹配值）---“部分匹配值”：前缀和后缀的最长共有元素的长度。</p>
<p><strong>核心思想 </strong>：在每次失配时，不是把 p 串往后移一位，而是把 p 串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次 p 串移动的步数就是通过查找 next[] 数组确定的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> p[N], s[M];</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p+<span class="number">1</span> &gt;&gt; m &gt;&gt; s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 求 next 过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KPM 匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果 j 有对应 p 串的元素， 且 s[i] != p[j+1], 则失配， 移动 p 串</span></span><br><span class="line">        <span class="comment">// 用 while 是由于移动后可能仍然失配，所以要继续移动直到匹配或整个 p 串移到后面（j = 0)</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="comment">// 当前元素匹配，j 移向 p 串下一位</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 匹配成功</span></span><br><span class="line">            cout &lt;&lt; (i - n) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j = ne[j];<span class="comment">// 继续匹配下一个子串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie 树</title>
    <url>/2021/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(13)--Trie%E6%A0%91/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>Trie: 高效地存储和查找字符串集合的数据结构 </p>
<span id="more"></span>
<h1 id="trie 树">Trie 树 </h1>
<p> 维护一个字符串集合，支持两种操作：</p>
<ol type="1">
<li><code>I x</code> 向集合中插入一个字符串 xx；</li>
<li><code>Q x</code> 询问一个字符串在集合中出现了多少次。</li>
</ol>
<p> 共有 N 个操作，输入的字符串总长度不超过 10^5，字符串仅包含小写英文字母。</p>
<hr>
<p> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx; <span class="comment">// 下标是 0 的点，既是根节点，也是空节点 </span></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,op,str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>合并集</title>
    <url>/2021/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(14)--%E5%90%88%E5%B9%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p> 并查集：</p>
<ol type="1">
<li> 快速将两集合合并 </li>
<li> 查询两个元素是否在一个集合中 </li>
</ol>
<span id="more"></span>
<h1 id="并查集"> 并查集 </h1>
<ul>
<li> 每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x] 表示 x 的父节点。</li>
<li> 树根：用 p[x] == x 来表示 </li>
<li>x 的集合编号：用 while(p[x] != x) x= p[x];</li>
<li> 合并集合：px 是 x 的集合编号，py 是 y 的集合编号。p[x] = y</li>
</ul>
<hr>
<p> 一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p>
<p> 现在要进行 m 个操作，操作共有两种：</p>
<ol type="1">
<li><code>M a b</code>，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li>
<li><code>Q a b</code>，询问编号为 a 和 b 的两个数是否在同一个集合中；</li>
</ol>
<hr>
<p> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="comment">// 核心操作 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">// 返回 x 的根节点 + 路径压缩  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;  </span><br><span class="line">      	<span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变式"> 变式 </h2>
<p> 给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。</p>
<p> 现在要进行 m 个操作，操作共有三种：</p>
<ol type="1">
<li><code>C a b</code>，在点 a 和点 b 之间连一条边，a 和 b 可能相等；</li>
<li><code>Q1 a b</code>，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；</li>
<li><code>Q2 a</code>，询问点 a 所在连通块中点的数量 </li>
</ol>
<hr>
<p> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N],siz[N];</span><br><span class="line"><span class="comment">// 核心操作 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">// 返回 x 的根节点 + 路径压缩  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        siz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;  </span><br><span class="line">      	<span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scnaf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">continue</span>;</span><br><span class="line">            size[<span class="built_in">find</span>(b)] += siz[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scnaf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">            <span class="built_in">prindf</span>(<span class="string">&quot;%d\n&quot;</span>,siz[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2021/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(15)--%E5%A0%86/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>如何手写一个堆</p>
<ol type="1">
<li>插入一个数</li>
<li>求集合当中的最小值</li>
<li>删除最小值</li>
<li>删除任意一个元素</li>
<li>修改任意一个元素</li>
</ol>
<span id="more"></span>
<h1 id="堆">堆</h1>
<p>基本结构：一棵完全二叉树。</p>
<ul>
<li>小根堆：父节点的值小于或等于子节点的值；</li>
<li>大根堆：父节点的值大于或等于子节点的值；</li>
</ul>
<p>存储：使用 1 维数组存储。假设存储根节点的下标为 x，则左子节点为 2x，右子节点为 2x+1。</p>
<p>操作：down(x);up(x);---- x 代表下标</p>
<h2 id="downx 操作">down(x)操作</h2>
<ul>
<li>本质是一个递归过程</li>
</ul>
<hr>
<p>输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。</p>
<hr>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;<span class="comment">// 比较当前节点的左子节点 </span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">// 比较当前节点的右子节点</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)<span class="comment">// 根据下标变换对应的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    size = n;</span><br><span class="line">    <span class="comment">// 建堆  O(n) 时间复杂度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i; i--) <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[size];</span><br><span class="line">        size--;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="upx 操作">up(x)操作</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u/<span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟堆">模拟堆</h2>
<p>维护一个集合，初始时集合为空，支持如下几种操作：</p>
<ol type="1">
<li><code>I x</code>，插入一个数 xx；</li>
<li><code>PM</code>，输出当前集合中的最小值；</li>
<li><code>DM</code>，删除当前集合中的最小值（数据保证此时的最小值唯一）；</li>
<li><code>D k</code>，删除第 kk 个插入的数；</li>
<li><code>C k x</code>，修改第 kk 个插入的数，将其变为 xx；</li>
</ol>
<p>现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。</p>
<hr>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],size;</span><br><span class="line"><span class="comment">//hp 是 heap pointer 的缩写，表示堆数组中下标到第 k 个插入的映射</span></span><br><span class="line"><span class="comment">//ph 是 pointer heap 的缩写，表示第 k 个插入到堆数组中的下标的映射</span></span><br><span class="line"><span class="comment">// 两个互为逆函数。</span></span><br><span class="line"><span class="keyword">int</span> ph[N], hp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;<span class="comment">// 比较当前节点的左子节点</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">// 比较当前节点的右子节点</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)<span class="comment">// 根据下标变换对应的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> k,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            size++;</span><br><span class="line">            m++;</span><br><span class="line">            ph[m] = size, hp[size] = m;</span><br><span class="line">            h[size] = x;</span><br><span class="line">            <span class="built_in">up</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,size);</span><br><span class="line">            size -- ;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k,size);</span><br><span class="line">            size -- ;</span><br><span class="line">            <span class="built_in">down</span>(k),</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k =ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会用 ph 和 hp 这两个数组呢？ 原因在于在删除第 k 个插入元素的操作中，我们首先得知道第 k 个插入元素在堆数组中的什么位置，即堆数组下标是啥。很显然，用一个 ph 数组来存储会方便查找。这样我们就知道了第 k 个插入的元素在哪了。然后我们需要做的是和堆尾元素交换，最后再在原来第 k 个元素所在的位置进行 down 和 up 操作。由于交换完后 ph[k]的值变了，为 ph[size]了，所以必须要在之前保存 ph[k]的值，不然无法进行 down 和 up 操作。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2021/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(16)--%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p> 普通的哈希表的存储结构，字符串的哈希方法.</p>
<span id="more"></span>
<h1 id="哈希表 -- 期望算法"> 哈希表 -- 期望算法 </h1>
<ol type="1">
<li> 存储结构
<ul>
<li> 开放寻址法 </li>
<li> 拉链法 </li>
</ul></li>
<li> 字符串哈希方式 </li>
</ol>
<p> 作用：把复杂的数据映射到简单数据。</p>
<h2 id="拉链法"> 拉链法 </h2>
<p> 维护一个集合，支持如下几种操作：</p>
<ol type="1">
<li><code>I x</code>，插入一个数 x；</li>
<li><code>Q x</code>，询问数 x 是否在集合中出现过；</li>
</ol>
<p> 现在要进行 N 次操作，对于每个询问操作输出对应的结果。</p>
<hr>
<p> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;<span class="comment">// 一般取质数 100010  取质数冲突的概率最小 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;<span class="comment">// 邻接表 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x 映射到 从 0-1e5 之间的数 </span></span><br><span class="line">    <span class="comment">// c++ 中如果是负数 那他取模也是负的 所以 加 N 再 % N 就一定是一个正数 </span></span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;<span class="comment">// 映射为了让余数是正数 </span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h); <span class="comment">// 将槽先清空 空指针一般用 -1 来表示 </span></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开放寻址法"> 开放寻址法 </h2>
<ul>
<li> 只开了一个一维数组 </li>
<li> 开发范围是数据长度的 2~3 倍 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 开放寻址法一般开 数据范围的 2~3 倍, 这样大概率就没有冲突了 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200003</span> ;<span class="comment">// 取质数冲突的概率最小 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> null = <span class="number">0x3f3f3f3f</span>;<span class="comment">// 规定空指针为 null 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;<span class="comment">//c++ 中如果是负数 那他取模也是负的 所以 加 N 再 % N 就一定是一个正数 </span></span><br><span class="line">	<span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h); <span class="comment">// 将槽先清空 空指针一般用 -1 来表示 </span></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            h[k] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串哈希 -- 字符串前缀哈希法"> 字符串哈希 -- 字符串前缀哈希法 </h1>
<p><strong> 快速判断两个字符串是否相等的时候使用 </strong></p>
<ul>
<li><p> 字符串看出 P 进制数 </p></li>
<li><p> 将字符串转换成数字 </p></li>
<li><p> 再模上一个较小的数 </p></li>
<li><p> 前缀和公式 $ h[i+1]=h[i]×P+s[i] ,i∈[0,n−1] $.h 为前缀和数组，s 为字符串数组 区间和公式 <span class="math inline">\(\mathbf{h[l,r]}=h[r]−h[l−1]×\mathbf{P^{r−l+1}}\)</span></p></li>
<li><p> 区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位， 乘上 $ P^2$ 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。</p></li>
</ul>
<p> 注意：</p>
<ul>
<li> 不能把某个字母映射成 0</li>
<li> 不考虑冲突 </li>
</ul>
<hr>
<p> 给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1] 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。</p>
<p> 字符串中只包含大小写英文字母和数字。</p>
<hr>
<p> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">// h[i] 前 i 个字符的 hash 值 </span></span><br><span class="line"><span class="comment">// 字符串变成一个 p 进制数字，体现了字符 + 顺序，需要确保不同的字符串对应不同的数字 </span></span><br><span class="line"><span class="comment">// P = 131 或  13331 Q=2^64，在 99% 的情况下不会出现冲突 </span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, str+<span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 前缀和 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1,r1) == <span class="built_in">get</span>(l2,r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>STL</title>
    <url>/2021/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(17)--STL/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<span id="more"></span>
<h1 id="stl">STL</h1>
<h2 id="vector-- 变长数组">vector-- 变长数组</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">倍增数组</span><br><span class="line"> size()  返回元素个数</span><br><span class="line"> empty()  返回是否为空</span><br><span class="line"> clear()  清空</span><br><span class="line"> front()&#x2F;back() 返回第一 &#x2F; 最后一个数</span><br><span class="line"> push_back()&#x2F;pop_back() 插入或弹出最后一个数</span><br><span class="line"> begin()&#x2F;end() 第一个数 &#x2F; 最后一个</span><br><span class="line"> 支持比较运算按字典序</span><br></pre></td></tr></table></figure>
<h3 id="pairst">pair&lt;S,T&gt;</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储 2 元组 </span><br><span class="line"></span><br><span class="line">first- 第一个元素</span><br><span class="line"></span><br><span class="line">second - 第二个元素</span><br><span class="line"></span><br><span class="line"> 支持比较元素，以 first 为第一个关键字，以 second 为第二关键字 &lt; 字典序 &gt;</span><br><span class="line"></span><br><span class="line"> make_pair(a,b) -- 构造函数</span><br></pre></td></tr></table></figure>
<h2 id="string-- 字符串">string-- 字符串</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line"><span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br></pre></td></tr></table></figure>
<h2 id="queue">queue</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">push()  向队尾插入一个元素</span><br><span class="line">front()  返回队头元素</span><br><span class="line">back()  返回队尾元素</span><br><span class="line">pop()  弹出队头元素</span><br></pre></td></tr></table></figure>
<h2 id="priority_queue---- 优先队列">priority_queue -- 优先队列</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优先队列，默认是大根堆 </span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">push()  插入一个元素</span><br><span class="line">top()  返回堆顶元素</span><br><span class="line">pop()  弹出堆顶元素</span><br><span class="line"> 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<h2 id="stack-- 栈">stack-- 栈</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">push()  向栈顶插入一个元素</span><br><span class="line">top()  返回栈顶元素</span><br><span class="line">pop()  弹出栈顶元素</span><br></pre></td></tr></table></figure>
<h2 id="deque-- 双端队列">deque-- 双端队列</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">front()&#x2F;back()</span><br><span class="line">push_back()&#x2F;pop_back()</span><br><span class="line">push_front()&#x2F;pop_front()</span><br><span class="line">begin()&#x2F;end()</span><br></pre></td></tr></table></figure>
<h2 id="setmapmultisetmultimap">set/map/multiset/multimap</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">begin()&#x2F;end()</span><br><span class="line">++, -- 返回前驱和后继，时间复杂度 O(logn)</span><br></pre></td></tr></table></figure>
<p><strong>set/multiset</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert()  插入一个数</span><br><span class="line">find()  查找一个数</span><br><span class="line">count()  返回某一个数的个数</span><br><span class="line">erase()		(1) 输入是一个数 x，删除所有 x   O(k + logn)</span><br><span class="line">            (2) 输入一个迭代器，删除这个迭代器</span><br><span class="line">lower_bound()&#x2F;upper_bound()</span><br><span class="line">lower_bound(x)  返回大于等于 x 的最小的数的迭代器</span><br><span class="line">upper_bound(x)  返回大于 x 的最小的数的迭代器</span><br></pre></td></tr></table></figure>
<p><strong>map/multimap</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert()  插入的数是一个 pair</span><br><span class="line">erase()  输入的参数是 pair 或者迭代器</span><br><span class="line">find()</span><br><span class="line">[]  注意 multimap 不支持此操作。 时间复杂度是 O(logn)</span><br><span class="line">lower_bound()&#x2F;upper_bound()</span><br></pre></td></tr></table></figure>
<h2 id="unordered_setunordered_mapunordered_multisetunordered_multi--- 哈希表">unordered_set/unordered_map/unordered_multiset/unordered_multi--- 哈希表</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">和上面类似，增删改查的时间复杂度是 O(1)</span><br><span class="line">不支持 lower_bound()&#x2F;upper_bound()， 迭代器的 ++，--</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="bitset--- 压位">bitset-- 压位</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitset&lt;10000&gt; s;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">&#x3D;&#x3D;, !&#x3D;</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line">count()  返回有多少个 1</span><br><span class="line">any()  判断是否至少有一个 1</span><br><span class="line">none()  判断是否全为 0</span><br><span class="line"></span><br><span class="line">set()  把所有位置成 1</span><br><span class="line">set(k, v)  将第 k 位变成 v</span><br><span class="line">reset()  把所有位变成 0</span><br><span class="line">flip()  等价于~</span><br><span class="line">flip(k) 把第 k 位取反</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并</title>
    <url>/2021/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(2)--%E5%BD%92%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="归并排序 - 分治"> 归并排序 - 分治 </h1>
<ul>
<li> 确定分界点 mid（l+r）/2 是下标 <br>
</li>
<li> 递归排序左右两区间 </li>
<li><strong> 归并 -- 两个有序的数组合并 </strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N];</span><br><span class="line"><span class="comment">// 归并模板 </span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">     <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">     <span class="built_in">merge_sort</span>(q, mid+<span class="number">1</span>, r);</span><br><span class="line">     <span class="keyword">int</span> k = <span class="number">0</span>,i = l, j = mid +<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(q[i] &lt; =q[j]) tmp[k++] = q[i++];</span><br><span class="line">         <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">     <span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">     <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++,j++ ) q[i] = tmp[j];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(3)--%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>​</p>
<span id="more"></span>
<h1 id="整数二分 -- 有序">整数二分 -- 有序</h1>
<ul>
<li><p>本质：</p>
<ul>
<li><p>二分某区间中满足某种性质的边界点</p></li>
<li><p>有单调性一定可以二分，二分不一定需要单调性</p></li>
</ul></li>
<li><p>mid = (l+r+1)/2</p></li>
<li><p>判断 mid 是否满足 -- 去更新区间</p>
<ul>
<li>满足：[mid , r] l = mid;</li>
<li>不满足 ： [l, mid -1] r = mid - 1;</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间 [l,r] 被划分成[l,mid] 和[mid+1,r] 时使用 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid; <span class="comment">//check() 判断 mid 是否满足性质 </span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r] 被划分成[l,mid - 1] 和 [mid ,r] 时使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="浮点二分 --- 有序">浮点二分 -- 有序</h1>
<ul>
<li>不需要像整数二分那样考虑边界</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开方</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="comment">// 确定精度 ，一般多 2 </span></span><br><span class="line">    <span class="keyword">while</span>(r - <span class="number">1</span> &gt; <span class="number">0.0000001</span>)<span class="comment">//for(int i = 0; i &lt; 100; i++) 相当于区间长度 /2^100</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/2021/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(4)--%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>​</p>
<span id="more"></span>
<h1 id="高精度">高精度</h1>
<h2 id="类型">类型</h2>
<ul>
<li>两个较大整数相加</li>
<li>两个较大整数相减</li>
<li>一个较大整数乘以比较小的数</li>
<li>一个较大整数除以比较小的数</li>
</ul>
<h2 id="计算 - 加法">计算 - 加法</h2>
<ul>
<li>存储 -- 用数组存储 （小端） 个为存在数组 [0] 的位置</li>
<li>单个加，逢十进一</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a, b;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;A,B;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算 - 减法">计算 - 减法</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span>  A[i] &gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">()</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>())  t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   	<span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a, b;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;A,B;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A,B);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算 - 乘法">计算 - 乘法</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;A;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算 - 除法">计算 - 除法</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span><span class="comment">//r 传入 r 的地址，便于直接对余数 r 进行修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">// 对 A 从最高位开始处理</span></span><br><span class="line">    &#123;  </span><br><span class="line">        r = r * <span class="number">10</span> + A[i];<span class="comment">// 将上次的余数 *10 在加上当前位的数字，便是该位需要除的被除数</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);<span class="comment">// 所得即为商在这一位的数字</span></span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于在除法运算中，高位到低位运算，因此 C 的前导零都在 vector 的前面而不是尾部，vector 只有删除最后一个数字 pop_back 是常数复杂度，而对于删除第一位没有相应的库函数可以使用，而且删除第一位，其余位也要前移，</span></span><br><span class="line">    <span class="comment">// 因此我们将 C 翻转，这样 0 就位于数组尾部，可以使用 pop 函数删除前导 0</span></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;A;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A,b,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt;r &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/2021/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(5)--%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>​</p>
<span id="more"></span>
<h1 id="前缀和与差分">前缀和与差分</h1>
<p>前缀和与差分是一对逆运算。</p>
<h2 id="前缀和">前缀和</h2>
<h3 id="一维前缀和">一维前缀和</h3>
<p>有一列整数序列:<span class="math inline">\(\mathbf{a}_1,\mathbf{a}_2,\mathbf{a}_3.....,\mathbf{a}_n\)</span>, 其前缀和:<span class="math inline">\(\mathbf{S}_n = \mathbf{a}_1+\mathbf{a}_2+\mathbf{a}_3+....+\mathbf{a}_n\)</span>.</p>
<p>作用：求上述序列中 [l,r] 的和，使用数组相加的时间复杂度为 O(n), 使用前缀和的时间复杂度为 O(1). <span class="math display">\[\mathbf{S}_{r-l} = \mathbf{S}_r - \mathbf{S}_{l-1}
\]</span> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维前缀和">二维前缀和</h3>
<figure>
<img src="/2021/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(5)--%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/ 前缀和与差分.png" alt="前缀和与差分"><figcaption aria-hidden="true">前缀和与差分</figcaption>
</figure>
<p>计算二维前缀和：<span class="math inline">\(\mathbf{S}_{[i,j]} =\mathbf{a}_{[1,1]}+\mathbf{a}_{[1,2]} +\mathbf{a}_{[1,j]}+\mathbf{a}_{[2,1]}+\mathbf{a}_{[2,2]}+....+\mathbf{a}_{[i,j]}\)</span></p>
<p>即：<span class="math inline">\(\mathbf{S}_{[\mathbf{i},\mathbf{j}]} = \mathbf{S}_{[\mathbf{i}-1，\mathbf{j}]}+\mathbf{S}_{[\mathbf{i}-1，\mathbf{j}]}-\mathbf{S}_{[\mathbf{i}-1，\mathbf{j}-1]}+\mathbf{a}_{[\mathbf{i}，\mathbf{j}]}\)</span></p>
<p>已知 (x1,y1),(x2,y2) 求得这一子矩阵的和<span class="math inline">\(\mathbf{S}=\mathbf{S}_{[\mathbf{x}_2,\mathbf{y}_2]} - \mathbf{S}_{[\mathbf{x}_1-1,\mathbf{y}_2]}-\mathbf{S}_{[\mathbf{x}_2,\mathbf{y}_1-1]}+\mathbf{S}_{[\mathbf{x}_1-1,\mathbf{y}_1-1]}\)</span></p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="comment">// 初始化前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>]- s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j];</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,x2,y1,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s[x2][y2] - s[x2][y1<span class="number">-1</span>] - s[x1<span class="number">-1</span>][y2] + s[x1<span class="number">-1</span>][y<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="差分">差分</h2>
<h3 id="一维差分">一维差分</h3>
<p>有一列整数序列:<span class="math inline">\(\mathbf{a}_1,\mathbf{a}_2,\mathbf{a}_3,...,\mathbf{a}_n\)</span> 构造：<span class="math inline">\(\mathbf{b}_1,\mathbf{b}_2,\mathbf{b}_3,...,\mathbf{b}_n\)</span> 使得：<span class="math inline">\(\mathbf{a}=\mathbf{b}_1+\mathbf{b}_2+\mathbf{b}_3+...+\mathbf{b}_n\)</span> 即: <span class="math inline">\(\mathbf{b}_1 = \mathbf{a}_1\)</span></p>
<p>​ <span class="math inline">\(\mathbf{b}_2 = \mathbf{a}_2 - \mathbf{a}_1\)</span></p>
<p>​ <span class="math inline">\(...\)</span></p>
<p>​ <span class="math inline">\(\mathbf{b}_n = \mathbf{a}_n - \mathbf{a}_{n-1}\)</span></p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">insert</span>(i,i,a[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i<span class="number">-1</span>];<span class="comment">// 将 b 数组转换为其前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维差分">二维差分</h3>
<figure>
<img src="/2021/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(5)--%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/ 前缀和与差分.png" alt="前缀和与差分"><figcaption aria-hidden="true">前缀和与差分</figcaption>
</figure>
<p>给定原矩阵 a[i,j], 构造差分矩阵 b[i,j], 使得 a[i,j] 是 b[i,j]的前缀和</p>
<p>差分核心操作：给以 (x1,y1) 为左上角,(x2,y2)为右下角的子矩阵中的所有数 a[i,j], 加上 c。</p>
<p>对于差分数组的影响:</p>
<p>​ <span class="math inline">\(\mathbf{b}_{[\mathbf{x}_1,\mathbf{y}_1]} \,+= \,C\)</span></p>
<p>​ <span class="math inline">\(\mathbf{b}_{[\mathbf{x}_1,\mathbf{y}_2+1]} \,-= \,C\)</span></p>
<p>​ <span class="math inline">\(\mathbf{b}_{[\mathbf{x}_1+1,\mathbf{y}_2]} \,-= \,C\)</span></p>
<p>​ <span class="math inline">\(\mathbf{b}_{[\mathbf{x}_2+1,\mathbf{y}_2+1]} \,+= \,C\)</span></p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m. q;</span><br><span class="line"><span class="keyword">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            a[i][j] = a[i<span class="number">-1</span>][j] + a[i][j<span class="number">-1</span>] -a[a<span class="number">-1</span>][j<span class="number">-1</span>] + b[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法</title>
    <url>/2021/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(6)--%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="双指针算法"> 双指针算法 </h1>
<p> 在快排和归并算法中都有运用。</p>
<p> 核心思想：把使用暴力双重 for 循环的 O(n^2) 的情况优化到 O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;i &amp;&amp; <span class="built_in">check</span>(i,j)) j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度 </p>
<hr>
<p> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(s[a[i]] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(7)--%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​</p>
<span id="more"></span>
<h1 id="位运算"> 位运算 </h1>
<p> 一个整数 n 的二进制表示中第 k 位是几。</p>
<p> 假设 n = 15 = (1111)2</p>
<ul>
<li> 先把第 K 位移到最后一位 n &gt;&gt; k;</li>
<li> 看个位是几 n&amp;1</li>
</ul>
<p> 结合上诉 (n&gt;&gt;k)&amp;1。</p>
<p>lowbit 操作：返回 x 的最后一位 1。</p>
<p> 例：x = 1010   lowbit(x) = 10</p>
<p> 实现 lowbit 操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//lowbit 操作实际为 x&amp;-x  </span></span><br><span class="line"><span class="comment">//x&amp;-x= x&amp;(~x+1)</span></span><br><span class="line"><span class="comment">// 假设 x = 1010...100...0</span></span><br><span class="line"><span class="comment">//  ~x = 0101...011..1</span></span><br><span class="line"><span class="comment">//~x+1 = 0101...100...0</span></span><br><span class="line"><span class="comment">// 即 x&amp;(~x+1) = 0000...100...0</span></span><br></pre></td></tr></table></figure>
<p> 应用：统计 x 里面 1 的个数 </p>
<p> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) x -= <span class="built_in">lowbit</span>(x),res++;<span class="comment">// 每次减去 x 的最后一位。</span></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 原码：<span class="math inline">\(\mathbf{x}\)</span> = 1010</p>
<p> 反码: <span class="math inline">\(\mathbf{x}_1\)</span> = 0101-------&gt;~<span class="math inline">\(\mathbf{x}\)</span></p>
<p> 补码：<span class="math inline">\(\mathbf{x}_2\)</span> = 0110-------&gt;~<span class="math inline">\(\mathbf{x}+1\)</span></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/2021/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(8)--%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​ 特指整数有序的离散化 </p>
<p> 假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p>
<p> 现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p>
<p> 接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p>
<span id="more"></span>
<h2 id="离散化"> 离散化 </h2>
<ul>
<li> 含义：把无限空间中有限的个体映射到有限的空间中去 </li>
<li> 目标：在不改变数据相对大小的条件下，对数据进行相应的缩小 </li>
<li> 注意：
<ul>
<li> 有重复元素需要去重。</li>
<li> 如何去算离散化后的值 ---- 二分 </li>
</ul></li>
</ul>
<hr>
<p> 假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p>
<p> 现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p>
<p> 接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和 </p>
<hr>
<p> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],s[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;</span><br><span class="line">vector&lt;PII&gt;add,query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!i || a[i] != a[i<span class="number">-1</span>])</span><br><span class="line">          a[j++] = a[i];</span><br><span class="line">        <span class="comment">//a[0] ~ a[j-1] 所有 a 中不重复的数 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去重 </span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 stl  alls.erase(unique(alls.begin(),alls.end()),alls.end());</span></span><br><span class="line">    <span class="comment">// 使用自己编写的 </span></span><br><span class="line">    <span class="comment">// 处理插入 unique</span></span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls),alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理前缀和 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++) s[i] = s[i <span class="number">-1</span>] + a[i];</span><br><span class="line">    <span class="comment">// 处理查询 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>区间合并</title>
    <url>/2021/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(9)--%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p> 给定 n 个区间 [l,r]，要求合并所有有交集的区间。</p>
<p> 注意如果在端点处相交，也算有交集。</p>
<p> 输出合并完成后的区间个数。</p>
<p> 例如：[1,3] 和 [2,6] 可以合并为一个区间 [1,6]。</p>
<span id="more"></span>
<h2 id="区间合并"> 区间合并 </h2>
<ul>
<li> 按区间左端点排序 </li>
<li> 判断区间之间的关系
<ul>
<li> 子集 </li>
<li> 交集 </li>
<li> 无交集 </li>
</ul></li>
<li> 区间合并 </li>
</ul>
<p> 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>,ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg :segs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first) <span class="comment">// 情况 1：两个区间无法合并 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况 2：两个区间可以合并，且区间 1 不包含区间 2，区间 2 不包含区间 1</span></span><br><span class="line">       <span class="comment">//(实际上也有情况 3：区间 1 包含区间 2，此时不需要任何操作，可以省略)</span></span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况 2：两个区间可以合并，且区间 1 不包含区间 2，区间 2 不包含区间 1</span></span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 (2)- 应用层</title>
    <url>/2022/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(2)-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<ul>
<li><p>网络应用的原理：网络应用协议的概念和实现方面</p>
<ul>
<li>传输层的服务模型</li>
<li>客户 - 服务器模式</li>
<li>对等模式(peer to peer)</li>
<li>内容分发网络</li>
</ul></li>
<li><p>网络应用的实例：互联网流行的应用层协议</p>
<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP/POP3/IMAP</li>
<li>DNS</li>
</ul></li>
<li><p>编程：网络应用程序</p>
<ul>
<li>Socket API-- 传输层提供的服务</li>
</ul></li>
</ul>
<span id="more"></span>
<h2 id="协议原理">协议原理</h2>
<h3 id="应用架构">应用架构</h3>
<ul>
<li><p>客户 - 服务器 (C/S) 体系结构 -- 达到一定量级后断崖式下降</p>
<ul>
<li><p>服务器</p>
<ul>
<li><p>一直运行</p></li>
<li><p>固定的 IP 地址和周知的端口号</p></li>
<li><p>扩展性：服务器场</p>
<ul>
<li>数据中心进行扩展</li>
<li>扩展性差</li>
</ul></li>
</ul></li>
<li><p>客户端</p>
<ul>
<li>主动与服务端通信</li>
<li>与互联网有间歇性的连接</li>
<li>可能是动态 IP 地址</li>
<li>不直接与其他客户端通信</li>
</ul></li>
</ul></li>
<li><p>对等模式(P2P: Peer To Peer)</p>
<ul>
<li><p>(几乎)没有一直运行的服务器</p></li>
<li><p>任意端系统之间可以进行通信</p></li>
<li><p>每一个节点即是客户端又是服务器</p>
<ul>
<li>自扩展性 - 新 peer 节点带来新的服务能力，当然也带来新的服务请求</li>
</ul></li>
<li><p>参与的主机间歇性连接且可以改变 IP 地址</p>
<ul>
<li>难以管理</li>
</ul></li>
</ul></li>
<li><p>混合模式: 客户端 - 服务器和对等体系结构</p>
<ul>
<li><p>Napster</p>
<ul>
<li><p>文件搜索：集中</p>
<ul>
<li>主机在中心服务器上注册其资源</li>
<li>主机向中心服务器查询资源位置</li>
</ul></li>
<li><p>文件传输：P2P</p>
<ul>
<li>任意 peer 节点之间</li>
</ul></li>
</ul></li>
<li><p>即时通信</p>
<ul>
<li><p>在线检测：集中</p>
<ul>
<li>当用户上线时，向中心服务器注册其 IP 地址</li>
<li>用户与中心服务器联系，以找到其在线好友的位置</li>
</ul></li>
<li><p>两个用户之间聊天：P2P</p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="进程通信">进程通信</h3>
<p>进程：在主机上运行的应用程序</p>
<ul>
<li><p>在同一主机内，使用进程间通信机制通信</p></li>
<li><p>不同主机，通过交换报文 (Message) 来通信</p>
<ul>
<li>使用 OS 提供的通信服务</li>
<li>按照应用协议交换报文 -- 借助传输层提供的服务</li>
</ul></li>
<li><p>具体实现</p>
<ul>
<li>客户端进程：发起通信的进程</li>
<li>服务器进程：等待连接的进程</li>
</ul></li>
<li><p>注意：P2P 架构的应用也有客户端进程和服务器进程之分</p></li>
</ul>
<h4 id="分布式通信进程">分布式通信进程</h4>
<ul>
<li><p>存在的问题</p>
<ol type="1">
<li><p>标示和寻址(服务用户)</p></li>
<li><p>传输层 - 应用层提供服务是如何的(服务)</p>
<ul>
<li>位置：层间界面的 SAP [服务访问点] (TCP/IP：socket)</li>
<li>形式：应用程序接口 API(TCP/IP：socket API)</li>
</ul></li>
<li><p>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用(用户使用服务)</p>
<ul>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，使用 OS 提供的 API，调用网络基础设施提供通信服务传报文，实现应用时序等。</li>
</ul></li>
</ol></li>
<li><p>解决方法</p>
<ol type="1">
<li><p>对进程进行编址 -addressing</p>
<p>本质上一对主机进程间的通信由 2 个端节点构成</p>
<ul>
<li><p>进程为了接收报文，必须有一个 <strong> 标识</strong>：<strong>SAP</strong>(发送也需要标示)</p>
<ul>
<li>主机：唯一的 32 位 IP 地址 -- 仅仅有 IP 地址不能够唯一标示一个进程；在一条端系统上有很多应用进程在运行</li>
<li>传输层协议：TCP 或 UDP</li>
<li>端口号</li>
</ul></li>
<li><p>一个进程：用 IP+port 标示 端节点</p></li>
</ul></li>
<li><p>传输层提供的服务 -- 需要穿过层间的信息</p>
<ul>
<li><p>层间接口必须要携带的信息</p>
<ul>
<li>要传输的报文(对于本层来说：SDU)</li>
</ul>
<ul>
<li>谁传的：对方的应用进程的标示：IP+TCP(UDP)端口</li>
<li>传给谁：对方的应用进程的标示：对方的 IP+TCP(UDP)端口</li>
</ul></li>
<li><p>传输层实体 (TCP 或者 UDP 实体) 根据这些信息进行 TCP 报文段 (UDP 数据报) 的封装</p>
<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将 IP 地址往下交 IP 实体，用于封装 IP 数据报：源 IP，目标 IP</li>
</ul></li>
</ul></li>
</ol></li>
</ul>
<h2 id="web-and-http">Web and HTTP</h2>
<h2 id="ftp">FTP</h2>
<h2 id="email">Email</h2>
<h3 id="smtp">SMTP</h3>
<h3 id="pop3">POP3</h3>
<h3 id="imap">IMAP</h3>
<h2 id="dns">DNS</h2>
<h2 id="p2p 应用">P2P 应用</h2>
<h2 id="cdn">CDN</h2>
<h2 id="tcpsocket 编程">TCP(Socket)编程</h2>
<h2 id="udp 套接字编程">UDP 套接字编程</h2>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>配置 SDL 第三方库</title>
    <url>/2021/01/07/%E9%85%8D%E7%BD%AESDL%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<h1 id="介绍"> 介绍 </h1>
<p>​ 记录了自己是怎么配置 SDL 第三方库，其中遇到的问题和解决方法 </p>
<span id="more"></span>
<h1 id="配置 sdl 第三方库"> 配置 SDL 第三方库 </h1>
<h2 id="环境"> 环境 </h2>
<ul>
<li>VScode</li>
<li>windows</li>
<li>MinGW64</li>
</ul>
<h2 id="下载 sdl"> 下载 SDL</h2>
<p><img src="/2021/01/07/%E9%85%8D%E7%BD%AESDL%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/SDL 下载.png" style="zoom:75%;"></p>
<p>​ 根据自己的编译器选择。</p>
<p>​ 下载完成后根据自己使用的是 64 位还是 32 位 MinGW 选择文件夹复制粘贴到 MinGW 文件夹中里面。我是 64 位 MinGW。所以在这里我选择 x86 的文件夹并复制粘贴。</p>
<p><img src="/2021/01/07/%E9%85%8D%E7%BD%AESDL%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ 选择 SDL 库文件夹.jpg" alt="选择 SDL 库文件夹" style="zoom:50%;"></p>
<p><img src="/2021/01/07/%E9%85%8D%E7%BD%AESDL%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/MinGW 文件夹选择.png" alt="MinGW 文件夹选择" style="zoom:50%;"></p>
<h2 id="配置 vscode"> 配置 VScode</h2>
<p>​ 要在 c_cpp_properties.json 中输入路径。</p>
<p>​ 要在 task.json 文件中链接静态库。“lmingw32”、"-lSDL2main"、"-lSDL2"。同时要将 SDL2.dll 文件放置在.exe 文件同级下。</p>
<p>​ 在 task.json 文件中使用 -I。g++ 有一个选项 <code>-I</code>。它允许将包含搜索路径添加到命令行.</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络 (1)- 计算机网络和 Internet</title>
    <url>/2021/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(1)-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8CInternet/</url>
    <content><![CDATA[<p>目标：</p>
<ul>
<li>了解基本术语与概念</li>
<li>掌握网络的基本原理</li>
</ul>
<span id="more"></span>
<h2 id="什么是 internet">什么是 Internet</h2>
<ul>
<li><p>网：是节点与边组成，与大小、形状无关的拓扑</p></li>
<li><p>计算机网络：</p>
<ul>
<li><p>路由器 ---- 网络层</p>
<p>交换机 ---- 链路层 ：传输数据 = 带宽(bps)</p></li>
<li><p>节点：</p>
<ul>
<li>设备：
<ul>
<li>数据交换节点</li>
<li>数据节点</li>
</ul></li>
<li>应用程序：主机及其运行的应用程序</li>
</ul></li>
<li><p>边：链路</p>
<ul>
<li>接入网链路：主机连接到互联网的链路</li>
<li>主干链路：路由器间的链路</li>
</ul></li>
<li><p>协议：对等层实体在通信过程中应该遵守的规则和集合</p>
<p>定义了报文格式和次序，以及在报文传输或接收或其他事件方面所采取的动作</p>
<p>PDU(协议数据单元)：Protocol Data Unit</p>
<p><strong>规范了语法、语义、时序和动作</strong></p></li>
</ul></li>
<li><p>作用：</p>
<ul>
<li><p>为分布式的应用进程提供基础设施，是网络存在的理由</p>
<p>无连接和面向连接的服务 ---(UDP/TCP)</p></li>
<li><p>使用通信设施进行通信的分布式应用</p></li>
</ul></li>
</ul>
<h2 id="网络结构">网络结构</h2>
<ul>
<li>网络结构：核心通过接入网将任意的网络边缘连接，实现端端互联
<ul>
<li>网络边缘：
<ul>
<li>主机</li>
<li>应用程序（客户端和服务器）</li>
</ul></li>
<li>网络核心：<strong>数据交换</strong>
<ul>
<li>互联着的路由器</li>
<li>网络的网络</li>
</ul></li>
<li>接入网、物理媒体：<strong>将边缘接入到网络核心</strong>
<ul>
<li>有线或无线通信链路</li>
</ul></li>
</ul></li>
</ul>
<h3 id="网络边缘">网络边缘</h3>
<ul>
<li><p>按模式划分为：</p>
<ul>
<li><p>端系统:</p></li>
<li><p>客户 / 服务模式(C/S): 可扩展性差，当到达一定程度后会出现断崖式下降</p></li>
<li><p>对等模式(peer-peer):</p>
<p>分布式，文件分发系统使用。既是客户端又是服务器，但服务器的扩容不能满足需求</p></li>
</ul></li>
<li><p>采用网络设施的面向连接服务 -- 端系统维持，网络核心不了解</p>
<ul>
<li><p>目标：在端系统之间传输数据</p></li>
<li><p>方式 ---- 握手：在数据传输之前做好准备</p></li>
<li><p>传输控制协议 ----<strong>TCP</strong></p>
<ul>
<li>可靠地、按顺序地传送数据：<strong>确认和重传</strong></li>
<li>流量控制：发送方不会淹没接收方</li>
<li>拥塞控制：当网络拥塞时，发送方降低发送速率</li>
</ul></li>
</ul></li>
<li><p>采用基础设施的无连接服务</p>
<ul>
<li>目标在端系统之间传输数据</li>
<li>UDP
<ul>
<li>无连接</li>
</ul></li>
<li>不可靠</li>
<li>无流量控制</li>
<li>无拥塞控制</li>
</ul></li>
</ul>
<h3 id="网络核心 --- 路由器的网状网络">网络核心 --- 路由器的网状网络</h3>
<ul>
<li><p>电路交换(线路交换)：</p>
<p>为每个呼叫预留一条专有电路；端到端的资源被分配给从源端到目标端的呼叫‘call’ 计算机之间的通信有突发性，如过使用线路交换，则浪费的片较多即使这个呼叫没有数据传递，这个片也不能够被别的呼叫使用。</p>
<ul>
<li><p>信令系统</p></li>
<li><p>独享资源：一旦建立起来就能够保证性能</p></li>
<li><p>如果呼叫没有数据发送，被分配的资源就会被浪费</p></li>
<li><p>传统电话网络采用</p></li>
<li><p>特点：</p>
<ul>
<li>链路带宽、交换能力</li>
<li>专用资源：不共享</li>
<li>保证性能</li>
<li>要求建立呼叫连接</li>
</ul></li>
<li><p>网络资源 (如带宽) 被分成片</p>
<p>不适合计算机之间的通信</p>
<ul>
<li>为呼叫分配片</li>
<li>如果某个呼叫没有数据，则其资源片处于空闲状态</li>
<li>将带宽分成片：
<ol type="1">
<li>频分 -FDM</li>
<li>时分 -TDM</li>
</ol></li>
</ul></li>
</ul></li>
<li><p>分组交换：<strong>存储转发</strong></p>
<p>发送和接收时一个事物的两个方面 (发送和接收时同时的)，传输延时只能算一遍 ---- 是一个<strong> 过程</strong></p>
<p>以分组为单位存储 - 转发方式；是突发数据的胜利者</p>
<ol type="1">
<li>网络带宽资源不再分分一个个片，传输时使用全部带宽；资源共享，按需使用(packet)</li>
<li>将要传送的数据分成一个个单位：分组；将分组从一个路由器传到相邻路由器(hop-- 跳), 一段段最终从源端到目标端。
<ul>
<li>在转发之前，节点必须收到整个分组</li>
<li>延迟比线路交换大</li>
<li>排队时间</li>
</ul></li>
<li>每段：采用链路的最大传输能力(带宽)</li>
<li>时分复用 -- 特殊 统计多路复用</li>
<li>优缺点：
<ul>
<li>适用于突发式数据传输
<ul>
<li>简单，不必呼叫</li>
<li>资源共享</li>
</ul></li>
<li>过度使用会造成网络拥塞，分组延时和丢失
<ul>
<li>对可靠地数据传输需要协议来约束：拥塞控制</li>
</ul></li>
</ul></li>
</ol>
<ul>
<li><p>排队和延迟：共享性的代价</p>
<ol type="1">
<li>如果到达速率 &gt; 链路的输出速率：
<ul>
<li>分组将会排队，等待传输</li>
<li>如果路由器的缓存用完了，分组将会被抛弃</li>
</ul></li>
</ol></li>
<li><p>网络核心的关键功能：</p>
<ul>
<li>路由 (<strong> 全局选择 </strong>)：查路由表决定分组采用的源到目标的路径 -------<strong> 路由算法</strong></li>
<li>转发 (<strong> 局部执行</strong>)：将分组从路由器的输入链路转移到输出链路</li>
</ul></li>
<li><p>分组交换允许跟多用户使用网络：假设</p>
<ul>
<li><p>1Mb/s</p></li>
<li><p>每个用户活动时 100kb/s，10% 的时间时活动的</p>
<ul>
<li><p>35 用户时，&gt;=10 个用户活动的概率为 0.0004</p>
<figure>
<img src="/2021/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(1)-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8CInternet/n 重伯努利模型.png" alt="计算公式"><figcaption aria-hidden="true">计算公式</figcaption>
</figure></li>
<li><p>当大于等于 10 时，路由器没有裕量。所以为 9，这样当暂时发生分组排队时，在后来也能及时将数据发出</p></li>
</ul></li>
</ul></li>
<li><p>种类：</p>
<ol type="1">
<li>数据报网络(datagram)：Internet
<ul>
<li>在通信之前，无须建立其一个连接，有数据就传输</li>
<li>每一个分组都是独立路由(路径不一样，可能会失序)</li>
<li>路由器根据分组的目标地址进行路由</li>
</ul></li>
<li>虚电路网络(virtual circuit)：X.25 和 ATM
<ul>
<li>信令</li>
</ul></li>
</ol></li>
</ul></li>
<li><p><strong>时延</strong> -- 主机传完不代表客户端能够立马接收到，时间和距离的延迟</p>
<ol type="1">
<li>传输时延</li>
<li>传播时延</li>
<li>处理时延</li>
</ol></li>
</ul>
<h3 id="接入网和物理媒体">接入网和物理媒体</h3>
<ul>
<li><p>接入方式：</p>
<ul>
<li>住宅接入网络(Modem): 调制解调器</li>
</ul>
<ol type="1">
<li>调制解调器:
<ol type="1">
<li>利用电话线，能保证的带宽只有 4kHz;</li>
<li>通过 Modem 调制解调可以在 56kHz 范围内使用，且不能与电话同时进行</li>
<li>DSL 使用 4kHz 以上的带宽进行上网，不影响电话，</li>
<li>上行 1M；下行 10M 传输速度</li>
</ol></li>
<li>有线电视信号线缆双向改造。(FDM/ 共享)
<ol type="1">
<li>非对称：最高 30Mbps 的下行，2Mbps 的上行</li>
<li>线缆和光纤网络将全家庭用户接入到 <strong>ISP</strong> 路由器</li>
<li>各用户共享到线缆头端的接入网络
<ul>
<li>与 DSL 不同，DSL 每个用户一个专用线路到 CO</li>
</ul></li>
</ol></li>
</ol>
<ul>
<li><p>单位接入网络</p>
<ul>
<li>通过交换机的级联</li>
</ul></li>
<li><p>无线接入网络</p>
<ul>
<li>无线 LANs:</li>
<li>广域无线接入</li>
</ul></li>
</ul></li>
<li><p>物理媒</p>
<ul>
<li>bit：在传输 - 接收对间传播</li>
<li>物理介质：在每个传输 - 接收对，跨越一种物理媒体</li>
<li>导引型：稳定，传的更远。沿着固体媒介
<ul>
<li>双绞线(TP)</li>
<li>同轴电缆</li>
<li>光缆：多模 / 单模</li>
</ul></li>
<li>非导引型：不稳定，易衰减。信号自由传播。双向
<ul>
<li>效应：<strong>反射、吸收、干扰</strong></li>
<li>地面微波</li>
<li>LAN</li>
<li>wide area 蜂窝</li>
<li>卫星</li>
</ul></li>
</ul></li>
</ul>
<h2 id="internet 结构和 isp">Internet 结构和 ISP</h2>
<ol type="1">
<li>端系统通过接入 ISPs 连接到互联网</li>
<li>接入 ISPs 相应的必须是互联的 -- 因此任何 2 个端系统可相互发送分组到对方</li>
</ol>
<ul>
<li><p>将每两个 ISPs 直接相连不可扩展需要 O(N)连接</p></li>
<li><p>将每个接入 ISP 都连接到全局 ISP，造成了竞争与合作</p></li>
<li><p>业务：全球与局域</p></li>
<li><p>Internet 结构：</p>
<ol type="1">
<li><p>松散的层次模型</p></li>
<li><p>中心：第一层 ISP 国家 / 国际覆盖，速率极高</p>
<ul>
<li>直接与其他第一层 ISP 相连</li>
<li>与大量的第二层 ISP 和其他客户网络相连</li>
</ul></li>
<li><p>第二层 ISP：更小些的 ISP</p>
<ul>
<li>与一个或多个第一层 ISPs，也可能与其他第二层 ISP</li>
<li>通过合作覆盖更大的范围</li>
</ul></li>
<li><p>一个分组要经过许多网络</p></li>
</ol></li>
<li><p>ISP 之间的连接</p>
<ul>
<li>POP：高层 ISP 面向客户网络的接入点，涉及费用结算</li>
<li>对等接入：2 个 ISP 对等互接，不涉及费用结算</li>
<li>IXP：多个对等 ISP 互联互通之处</li>
<li>ICP 自己部署专用网络，同时和各级 ISP 连接</li>
</ul></li>
</ul>
<h2 id="分组延时丢失和吞吐量">分组延时、丢失和吞吐量</h2>
<ul>
<li><p>造成分组丢失和延时的原因：</p>
<ul>
<li>分组到达链路的速率超过了链路输出的能力</li>
<li>分组等待排到对头、被传输</li>
</ul></li>
<li><p>四种分组延时：</p>
<ol type="1">
<li><p>节点处理延时</p>
<ul>
<li>检查 bit 级差错</li>
<li>检查分组首部和决定将分组导向何处</li>
</ul></li>
<li><p>排队延时</p>
<ul>
<li><p>在输出链路上等待传输的时间</p></li>
<li><p>依赖于路由器的拥塞程度</p></li>
<li><p>取决于流量强度 I</p>
<ul>
<li>a = 分组到达队列的平均速率</li>
<li>流量强度 = La/R</li>
<li>La/R ~ 0: 平均排队时延很小</li>
<li>La/R -&gt; 1: 延时变得很大</li>
<li>La/R &gt;= 1: 比特到达队列的速率超过了从该队列输出的速率，平均排队延时将趋向无穷大, 会丢包 <strong>注意: 设计系统时流量强度不能大于 1</strong></li>
<li>TTL(Time to live): 生存时间，过一个路由器减一，为 0 返回原主机。在 ICMP 协议规定。</li>
</ul></li>
</ul></li>
<li><p>传输延时</p>
<ul>
<li>R = 链路带宽(bps)</li>
<li>L = 分组长度(bits)</li>
<li>将分组发送到链路上的时间 = L/R</li>
<li>存储转发延时</li>
</ul></li>
<li><p>传播延时</p>
<ul>
<li>d = 物理链路的长度</li>
<li>s = 在媒体上的传播速度(~$ 2 ^8 m/sec$)</li>
<li>传播时延 = d/s</li>
</ul></li>
<li><p>节点延时：</p>
<ul>
<li>节点延时计算: <span class="math inline">\(d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}\)</span> <span class="math display">\[\begin{align}
 &amp;d_{proc} = 处理延时  \qquad  通常是微秒数量级或更少
 \\
 &amp;d_{queue} = 排队延时  \qquad 取决于拥塞程度
 \\
 &amp;d_{trans} = 传输延时 =L/R，对低速率的链路而言很大(如拨号)，通常为微秒级到毫秒级
 \\
 &amp;d_{prop} = 传播时延 \qquad 几微秒到几百毫秒 \\
 \end{align}
 \]</span></li>
</ul></li>
</ol></li>
<li><p>分组丢失：</p>
<ul>
<li><p>链路的队列缓冲区容量有限</p></li>
<li><p>当分组到达一个满的队列时，该分组将会丢失</p></li>
<li><p>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</p></li>
</ul></li>
<li><p>吞吐量：</p>
<ul>
<li><p>在源端和目标端之间传输的速率(数据量 / 单位时间)</p>
<ul>
<li>瞬间吞吐量：一个时间点的速率</li>
<li>平均吞吐量：一个长时间内的平均值</li>
<li>瓶颈链路：端到端路径上，限制端到端吞吐的链路</li>
</ul></li>
</ul></li>
</ul>
<h2 id="协议层次及服务模型">协议层次及服务模型</h2>
<ul>
<li><p>协议层次：</p>
<ul>
<li><p>网络是一个复杂的系统：<strong>模块化</strong></p>
<ol type="1">
<li>网络功能繁杂</li>
<li>构成元素多</li>
<li>使用分层的方式来解决复杂的网络设计与实现
<ul>
<li><p>将网络功能分层，<strong>功能 </strong> 明确，<strong>层次 </strong> 清晰，可以给上层提供 <strong> 服务</strong></p></li>
<li><p>本层协议实体相互执行交互执行本层的 <strong> 协议动作</strong>，目的时实现本层功能，通过接口为上层提供服务</p></li>
<li><p>在实现本层本层的协议的时候，直接利用了下层所提供的服务</p></li>
</ul></li>
</ol></li>
<li><p>服务与服务访问点</p>
<ul>
<li><p>服务(Service)：低层实体想上层实体提供它们之间的通信能力</p>
<ul>
<li>服务用户</li>
<li>服务提供者</li>
</ul></li>
<li><p>原语 (primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互 --<strong> 形式(API)</strong></p></li>
<li><p>服务访问点 SAP(Services Access Point)：上层使用下层提供的服务通过层间的接口 -- 地点</p>
<ul>
<li>例子：邮箱</li>
<li>地址(ip address): 下层的一个实体支撑着上层的多个实体，SAP 有标志不同上层实体的作用</li>
<li>可以有不同的实现，队列</li>
<li>例子：传输层的 SAP：端口(port)</li>
</ul></li>
<li><p>服务的类型</p>
<ul>
<li><p>面向连接的服务和无连接的服务 - 方式</p>
<ul>
<li><p>面向连接的服务</p>
<ol type="1">
<li><p>连接(connection): 两个同信实体为进行通信而建立的一种结合</p></li>
<li><p>通信过程：建立连接，通信，拆除连接</p></li>
<li><p>例子：网络层的连接被称为虚电路</p></li>
<li><p>适用范围：对于大的数据块要传输；不适合小的零星报文</p></li>
<li><p>特点：保序</p></li>
<li><p>服务类型：</p>
<ul>
<li>可靠的信息流 -- 传送页面(可靠的获得，通过接收方的确认)</li>
<li>可靠的字节流 -- 远程登陆</li>
<li>不可靠的连接 -- 数字化声音</li>
</ul></li>
</ol></li>
<li><p>无连接的服务：</p>
<ol type="1">
<li><p>无连接的服务：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃(如寄信)</p></li>
<li><p>特点：不可靠、可能重复、可能失序</p></li>
<li><p>IP 分组，数据包</p></li>
<li><p>使用范围：适合传送零星数据</p></li>
<li><p>服务类型：</p>
<ul>
<li>不可靠的数据报 -- 电子方式的函件</li>
<li>有确认的数据报 -- 挂号信</li>
<li>请求回答 -- 信息查询</li>
</ul></li>
</ol></li>
</ul></li>
</ul></li>
<li><p>服务和协议</p>
<ul>
<li><p>区别：</p>
<ul>
<li>服务 (Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(Primitive) 来操作的，垂直。</li>
<li>协议 (Protocal): 对等层实体(peer entity) 之间在相互通信的过程中，需要遵循的规则的集合，水平。</li>
</ul></li>
<li><p>联系</p>
<ul>
<li>本层 <strong> 协议的实现 </strong> 要靠下层提供的服务来实现</li>
<li>本层实体通过协议为上层提供 <strong> 更高级的服务</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>数据单元(DU)</p>
<figure>
<img src="/2021/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(1)-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8CInternet/ 数据单元.png" alt="数据单元"><figcaption aria-hidden="true">数据单元</figcaption>
</figure>
<ul>
<li><p>各层次的协议数据单元(PDU):</p>
<ol type="1">
<li>应用层：报文(message)</li>
<li>传输层：报文段(segment) -- TCP 段，UDP 数据报</li>
<li>网络层：分组 packet(如果无连接方式：数据报 datagram)</li>
<li>数据链路层：帧(frame)</li>
<li>物理层：位(bit)</li>
</ol></li>
</ul></li>
<li><p>分层处理和实现复杂系统</p>
<ul>
<li><p>概念化：结构清晰，便于标识网络组件，以及描述其相互关系</p></li>
<li><p>结构化：模块化更易于维护和系统升级</p>
<ul>
<li><p>改变某一层服务的实现不影响系统中的其他层次</p>
<ul>
<li>对于其他层次而言是透明的</li>
</ul></li>
</ul></li>
<li><p>效率变低</p></li>
</ul></li>
<li><p>Internet 协议栈 -- 数据的封装与解封装过程</p>
<ul>
<li><p>应用层：网络应用</p>
<ul>
<li>为人类用户或者其他应用进程提供网络应用服务</li>
<li>FTP，SMTP，HTTP，DNS</li>
</ul></li>
<li><p>传输层：主机之间的数据传输</p>
<ul>
<li>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠地通信</li>
<li>TCP,UDP</li>
</ul></li>
<li><p>网络层：为数据报从源目的选择路由</p>
<ul>
<li>主机主机之间的通信，端到端通信，不可靠</li>
<li>IP，路由协议</li>
</ul></li>
<li><p>链路层：相连网络节点之间的数据传输</p>
<ul>
<li>2 个相邻 2 点的通信，点到点通信，可靠或不可靠</li>
<li>点对点协议 PPP，802.11(wifi),Ethernet</li>
</ul></li>
<li><p>物理层：在线路上传送 bit</p></li>
</ul></li>
<li><p>ISO/OSI 参考模型 -- 在上述协议栈的应用层和传输层多了两层</p>
<ul>
<li>表示层：允许应用解释传输的数据，e.g., 加密，压缩，机器相关的表示转换</li>
<li>会话层：数据交换的同步，检查点，恢复。</li>
<li>在协议栈中是应用层中去处理</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
